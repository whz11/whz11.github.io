{"pages":[],"posts":[{"title":"dfs","text":"DFS 深度优先搜索 深度优先搜索算法（英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。 123456789101112131415161718192021int check(参数){ if(满足条件) return 1; return 0;}void dfs(int step){ 判断边界 { 相应操作 } 尝试每一种可能 { 满足check条件 标记 继续下一步dfs(step+1) 恢复初始状态（回溯的时候要用到） }} 1、全排列问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;string.h&gt;int n;char a[15];char re[15];int vis[15];//假设有n个字符要排列，把他们依次放到n个箱子中//先要检查箱子是否为空，手中还有什么字符，把他们放进并标记。//放完一次要恢复初始状态，当到n+1个箱子时，一次排列已经结束void dfs(int step){ int i; if(step==n+1)//判断边界 { for(i=1;i&lt;=n;i++) printf(\"%c\",re[i]); printf(\"\\n\"); return ; } for(i=1;i&lt;=n;i++)//遍历每一种情况 { if(vis[i]==0)//check满足 { re[step]=a[i]; vis[i]=1;//标记 dfs(step+1);//继续搜索 vis[i]=0;//恢复初始状态 } } return ;}int main(void){ int T; scanf(\"%d\",&amp;T); getchar(); while(T--) { memset(a,0,sizeof(a)); memset(vis,0,sizeof(vis));//对存数据的数组分别初始化 scanf(\"%s\",a+1); n=strlen(a+1); dfs(1);//从第一个箱子开始 } return 0;}//方法2class Solution {public: int n; vector&lt;int&gt; vis; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; vec; void dfs(int cur,vector&lt;int&gt; &amp;nums){ if(cur==n) { res.push_back(vec); return ; } for(int i=0;i&lt;nums.size();i++){ if(!vis[i]){ vec[i]=nums[cur]; vis[i]=1; dfs(cur+1,nums); vis[i]=0; } } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { n=nums.size(); vis=vector&lt;int&gt;(n); vec=vector&lt;int&gt;(n); dfs(0,nums); return res; }};","link":"/2020/03/21/dfs/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/20/hello-world/"},{"title":"springboot1","text":"关于Springboot-Mybatis无配置文件注解版的思考用过springboot后，我们发现，整个项目除了application.properties文件，其他配置文件，如mybatis-config.xml、mapper.xml都不需要，甚至数据库java配置类也不需要，非常的方便。 整个项目除了pom.xml文件和application.properties文件外，没有其他配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xz&lt;/groupId&gt; &lt;artifactId&gt;blog&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;blog&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;5.0.8.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL (JSP standard Tag Library) JSP 标准标签库 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt; 注意，这个scope需要被注释掉--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring Boot的JPA依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--在导入druid数据源时，也就是外部数据源，我们必须导入相关依赖，因此我尝试将springboot默认数据源的相关依赖也导入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.ibatis/ibatis-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ibatis&lt;/groupId&gt; &lt;artifactId&gt;ibatis-core&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动 - https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.1_3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- end --&gt; &lt;!--redis jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--注意此次必须要放在此目录下才能被访问到 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; --&gt; &lt;/build&gt;&lt;/project&gt; application.properties配置 application.properties文件内容主要是配置了下数据库连接信息（必须配置）以及tomcat server的端口号（默认是8080，如果没有修改tomcat端口号，这部分也是可以不用配置的），项目中application.properties文件配置内容如下: 123456 #mysql配置spring.datasource.url=jdbc:mysql://localhost:3306/ssmstu?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=bjtungircspring.datasource.driver-class-name=com.mysql.jdbc.Drivermybatis.typeAliasesPackage=com.tqh.demo.model 具体代码 接下来就可以直接写controller、mapper、model、service里面的java代码了 首先按model开始讲起： a、model—-Person.java 定义了一个POJO类12345678910111213141516171819202122232425262728293031323334353637383940414243packege ....import ....public class Person { private Integer id; private String name; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age ; }} DAO层设计—mapper—》UserMapper.java 是一个接口类，在springmvc框架中，我们是需要为每一个mapper类写xml配置文件，例如UserMapper.xml，该文件负责具体的mapper类中的方法实现，因此我们不需要写dao的实现，就可以直接在service里面直接调用dao的方法了,mybatis会默认把UserMapper.xml映射为dao的实现。 在springboot中，我们甚至不用创建UserMapper.xml文件，可以直接在UserMapper.java里面，添加注解进行dao层操作，然后在启动类里面添加@MapperScan(“com.xz.blog.mapper”) //包扫描，即可(不过我还是喜欢@mapper在每个mapper文件，感觉@MapperScan容易报错，老是扫描不到)。 UserMapper.java123456789101112131415161718192021222324252627282930313233343536373839@Mapperpublic interface UserMapper { /** * 方式1：使用注解编写SQL。 */ @Select(\"select * from t_user\") List&lt;User&gt; list(); /** * 方式2：使用注解指定某个工具类的方法来动态编写SQL. */ @SelectProvider(type = UserSqlProvider.class, method = \"listByUsername\") List&lt;User&gt; listByUsername(String username); /** * 延伸：上述两种方式都可以附加@Results注解来指定结果集的映射关系. * * PS：如果符合下划线转驼峰的匹配项可以直接省略不写。 */ @Results({ @Result(property = \"userId\", column = \"USER_ID\"), @Result(property = \"username\", column = \"USERNAME\"), @Result(property = \"password\", column = \"PASSWORD\"), @Result(property = \"mobileNum\", column = \"PHONE_NUM\") }) @Select(\"select * from t_user\") List&lt;User&gt; listSample(); /** * 延伸：无论什么方式,如果涉及多个参数,则必须加上@Param注解,否则无法使用EL表达式获取参数。 */ @Select(\"select * from t_user where username like #{username} and password like #{password}\") User get(@Param(\"username\") String username, @Param(\"password\") String password); @SelectProvider(type = UserSqlProvider.class, method = \"getBadUser\") User getBadUser(@Param(\"username\") String username, @Param(\"password\") String password);} UserService.java12345678910111213141516171819202122@Servicepublic class UserService { @Autowired public UserMapper userMapper; // 获取单个用户信息 @Transactional //添加事务管理 public Person selectUser(int id) { return userMapper.selectUser(id); } //获取所有的用户信息 @Transactional public ArrayList&lt;Person&gt; selectAllUser() { return userMapper.selectAllUser(); } } Controller层123456789101112131415161718192021222324252627282930313233343536//@RestController@Controller//@ResponseBody//testController返回的不是页面,Controller返回的是页面 testController=Controller + ResponseBodypublic class UserController { @Autowired private UserService userService; @RequestMapping(\"/showUser/{id}\") public String selectUser (@PathVariable int id,Model model){ model.addAttribute(\"name\", userService.selectUser(id).toString()); return \"greets\"; } @RequestMapping(\"/showUser/all\") public String selectAllUser(){ return userService.selectAllUser().toString(); } @RequestMapping(\"/name\") public String name() { System.out.println(\"============================================\"); return \"hello\"; } /** @RequestMapping(\"/greet\") public String greeting(@RequestParam(value = \"name\", required = false, defaultValue = \"World\") String name, Model model) { model.addAttribute(\"name\", name); return \"greets\"; } **/ } 理解@controller和@Restcontroller两个注解，简单可以这么理解：RestController返回的不是页面,Controller返回的是页面 RestController=Controller + ResponseBodyreturn “greets”后，springboot是怎么定位到页面的：springboot的页面默认是放在:templates下面的，查询时默认文件的后缀名是html,也就是说默认是支持html文件的，但是jsp文件是不推荐的，需要额外配置。默认前缀名是通过return返回的字符串进行查找，如果找到了，就直接返回该页面文件视图，否则就直接返回默认的页面。总结归纳：1、springboot+mybatis只需要application.properties文件就可以了，里面只需要配置下server.port（tomcat端口号，如果是8080，连该端口号也不需要配置），其次配置下mysql的连接属性. 2、springboot集成mybatis不需要mybatis-config.xml也不需要mapper.xml，也不需要相应的配置类(配置事务和数据源)。原因在于springboot提供的mybatis-spring-boot-starter，使用注解解决一切问题，注意一定要在启动类里面@MapperScan(“com.xz.blog.mapper”) //包扫描，否则注解会无效。（资料：[](https://www.cnblogs.com/shanheyongmu/p/6868669.html） 3、Spring boot不建议使用jsp开发web。而是推荐使用Thymeleaf来作为模板引擎开发web项目。 spring-boot项目静态文件目录：/src/java/resources/static spring-boot项目模板文件目录：/src/java/resources/templates html文件在/src/java/resources/templates下。 如果要使用jsp来开发web，需要自行配置。4、controller层，代码中注意理解@controller和@Restcontroller两个注解，简单可以这么理解： RestController返回的不是页面,Controller返回的是页面 RestController=Controller + ResponseBody","link":"/2020/03/21/springboot1/"},{"title":"springboot1","text":"spring data jpa方法命名规则 如果命名不正确会出现 Spring Data JPA: No property foo found for type BarNo property user found for type 1234public interface UserRepository extends JpaRepository&lt;User, Long&gt;{ User findByName(String userName);} 可以看出实体类字段是userName,而repository却是findByName!改为findByUserName就好了 参考https://blog.csdn.net/j080624/article/details/82559318 https://www.cnblogs.com/oxygenG/p/10057525.html","link":"/2020/03/21/springboot2/"},{"title":"springboot3","text":"SpringBoot之 session和拦截器 Session:在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。 最近同学小组做电商商城，需要跳转页面后，还能保持登录信息。未登录时， 除了访问登录界面和商品页面，其他的界面被访问的时候被拦截且返回到登录页面。网上搜了半天，大概可以通过session，jwt，shiro等，由于本项目只有一种角色不需要鉴权，所以只需session操作。 首先， 我们要创建一个存放session登录信息的工具类: 12345package com.ecommerce.web.util;public class ConstantUtils { public final static String USER_SESSION_KEY=\"USER\";} 然后， 当用户成功登录以后，将用户信息作为一个session对象存放起来。 12345678910111213141516171819package com.ecommerce.web.controller;@PostMapping(\"/login\")public Object login( @RequestParam(\"id\") int id, @RequestParam(\"password\") String password HttpServletRequest request) throws JSONException, NoFindException { if (userService.login(id, password)) { //如果成功了，聚合需要返回的信息 User user =userService.search(id); //在session里注入用户信息，之后网页请求时，头部带session，通过拦截器判断是否有用户信息 request.getSession().setAttribute(ConstantUtils.USER_SESSION_KEY,user); return displayUtil.result(displayUtil.secret(user),\"登录成功\"); } else return displayUtil.result(null,\"登录失败\");} 此时我们尚未添加拦截器， 登录以后可以在任何其他页面拿到session中的用户信息。 拦截器:上面的session实现了之后 ， 无论用户登录与否， 项目的页面是都可以访问的， 现在创建拦截器。(未登录不可访问除登录页面以外的其他页面). 首先，创建拦截器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.ecommerce.web.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.ecommerce.web.entity.User;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import com.ecommerce.web.util.ConstantUtils;@Componentpublic class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { User user = (User) request.getSession().getAttribute(ConstantUtils.USER_SESSION_KEY); //如果session中没有user，表示没登陆 if (user == null){ //这个方法返回false表示忽略当前请求，如果一个用户调用了需要登陆才能使用的接口，如果他没有登陆这里会直接忽略掉 //当然你可以利用response给用户返回一些提示信息，告诉他没登陆 response.sendRedirect(request.getContextPath()+\"/\"); //到时把这改成登录页面的地址 return false; }else { return true; //如果session里有user，表示该用户已经登陆，放行，用户即可继续调用自己需要的接口 } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // TODO Auto-generated method stub HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // TODO Auto-generated method stub HandlerInterceptor.super.afterCompletion(request, response, handler, ex); }} 然后注入拦截器 ( addPathPatterns 是指为哪些地址添加拦截器， /** 是所有。excludePathPatterns 是指不需要拦截器的地址， 这里除了登录 和退出登录 ) 123456789101112131415161718192021222324252627package com.ecommerce.web.config;import com.ecommerce.web.interceptor.LoginInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfigurer implements WebMvcConfigurer { @Autowired LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // TODO Auto-generated method stub // addPathPatterns(\"/**\") 表示拦截所有的请求， // excludePathPatterns(\"/login\", \"/register\") 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问 registry.addInterceptor(loginInterceptor) .addPathPatterns(\"/user/**\") //我在controller层中把有关用户的controller在类上注释@RequestMapping(\"/user\") .excludePathPatterns(\"/user/register\",\"/user/login\"); }} 这样，当我们未登录的时候，就会重定向到”/(登录)” 地址下面。 实现了登录拦截。 退出登陆:即销毁session 12345@PostMapping(\"/logout\")public Object logout(HttpServletRequest request){ request.getSession().removeAttribute(ConstantUtils.USER_SESSION_KEY); return displayUtil.result(null,\"退出成功\");} postman测试后有效 [项目源码]（https://github.com/gcs104/e-commerceWeb）","link":"/2020/03/21/springboot3/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"}],"categories":[]}