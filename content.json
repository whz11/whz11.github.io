{"pages":[],"posts":[{"title":"RestTemplate","text":"转载 详解 RestTemplate 操作作为开发人员，我们经常关注于构建伟大的软件来解决业务问题。数据只是软件完成工作时要处理的原材料。但是如果你问一下业务人员，数据和软件谁更重要的话，他们很可能会选择数据。数据是许多业务的生命之血。软件通常是可以替换的，但是多年积累的数据是永远不能替换的。 近几年来,以信息为中心的表述性状态转移(Representational State Transfer，REST)已经称为替代传统SOAP Web 服务的流行方案.SOAP关注的一般是行为和处理,而REST关注的是要处理的数据. 从Spring3.0开始,Spring为创建Rest API提供了良好的支持. REST提供了一个更简单的可选方案。另外，很多的现代化应用都会有移动或富JavaScript客户端，它们都会使用运行在服务器上REST API。 REST的基础知识参考我的这篇文章: Restful API 设计指南 当谈论REST时，有一种常见的错误就是将其视为“基于URL的Web服务”——将REST作为另一种类型的远程过程调用（remote procedure call，RPC）机制，就像SOAP一样，只不过是通过简单的HTTP URL来触发，而不是使用SOAP大量的XML命名空间 恰好相反，REST与RPC几乎没有任何关系。RPC是面向服务的，并关注于行为和动作；而REST是面向资源的，强调描述应用程序的事物和名词。 更简洁地讲，REST就是将资源的状态以最适合客户端或服务端的形式从服务器端转移到客户端（或者反过来）。 在REST中，资源通过URL进行识别和定位。至于RESTful URL的结构并没有严格的规则，但是URL应该能够识别资源，而不是简单的发一条命令到服务器上。再次强调，关注的核心是事物，而不是行为。 Spring 中如何使用Rest资源借助 RestTemplate，Spring应用能够方便地使用REST资源Spring的 RestTemplate访问使用了模版方法的设计模式. 模版方法将过程中与特定实现相关的部分委托给接口,而这个接口的不同实现定义了接口的不同行为. RestTemplate定义了36个与REST资源交互的方法，其中的大多数都对应于HTTP的方法。其实，这里面只有11个独立的方法，其中有十个有三种重载形式，而第十一个则重载了六次，这样一共形成了36个方法。 delete() 在特定的URL上对资源执行HTTP DELETE操作 exchange()在URL上执行特定的HTTP方法，返回包含对象的ResponseEntity，这个对象是从响应体中映射得到的 execute() 在URL上执行特定的HTTP方法，返回一个从响应体映射得到的对象 getForEntity() 发送一个HTTP GET请求，返回的ResponseEntity包含了响应体所映射成的对象 getForObject() 发送一个HTTP GET请求，返回的请求体将映射为一个对象 postForEntity()POST 数据到一个URL，返回包含一个对象的ResponseEntity，这个对象是从响应体中映射得到的 postForObject() POST 数据到一个URL，返回根据响应体匹配形成的对象 headForHeaders() 发送HTTP HEAD请求，返回包含特定资源URL的HTTP头 optionsForAllow() 发送HTTP OPTIONS请求，返回对特定URL的Allow头信息 postForLocation() POST 数据到一个URL，返回新创建资源的URL put() PUT 资源到特定的URL 实际上,由于Post 操作的非幂等性,它几乎可以代替其他的CRUD操作. Get请求 RestTemplate 的get方法有以上几个,可以分为两类: getForEntity() 和 getForObject() 首先看 getForEntity() 的返回值类型 ResponseEntity ResponseEntity getForEntity()1看一下 ResponseEntity 的文档描述: 可以看到 它继承了HttpEntity. 封装了返回的响应信息,包括 响应状态,响应头 和 响应体. 在测试之前我们首先 创建一个Rest服务,模拟提供Rest数据,这里给出Controller层代码,具体可以查看源码,文章最后会给出: 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author itguang * @create 2017-12-17 10:37 **/@RestControllerpublic class UserController { @Autowired private UserService userService; @RequestMapping(value = \"getAll\") public List&lt;UserEntity&gt; getUser() { List&lt;UserEntity&gt; list = userService.getAll(); return list; } @RequestMapping(\"get/{id}\") public UserEntity getById(@PathVariable(name = \"id\") String id) { return userService.getById(id); } @RequestMapping(value = \"save\") public String save(UserEntity userEntity) { return \"保存成功\"; } @RequestMapping(value = \"saveByType/{type}\") public String saveByType(UserEntity userEntity,@PathVariable(\"type\")String type) { return \"保存成功,type=\"+type; }} 测试: getForEntity无参数的 getForEntity 方法 12345678910111213@RequestMapping(\"getForEntity\") public List&lt;UserEntity&gt; getAll2() { ResponseEntity&lt;List&gt; responseEntity = restTemplate.getForEntity(\"http://localhost/getAll\", List.class); HttpHeaders headers = responseEntity.getHeaders(); HttpStatus statusCode = responseEntity.getStatusCode(); int code = statusCode.value(); List&lt;UserEntity&gt; list = responseEntity.getBody(); System.out.println(list.toString()); return list; } 有参数的 getForEntity 请求,参数列表,可以使用 {} 进行url路径占位符 12345678//有参数的 getForEntity 请求,参数列表 @RequestMapping(\"getForEntity/{id}\") public UserEntity getById2(@PathVariable(name = \"id\") String id) { ResponseEntity&lt;UserEntity&gt; responseEntity = restTemplate.getForEntity(\"http://localhost/get/{id}\", UserEntity.class, id); UserEntity userEntity = responseEntity.getBody(); return userEntity; } 有参数的 get 请求,使用map封装参数 1234567891011//有参数的 get 请求,使用map封装参数@RequestMapping(\"getForEntity/{id}\")public UserEntity getById4(@PathVariable(name = \"id\") String id) { HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"id\",id); ResponseEntity&lt;UserEntity&gt; responseEntity = restTemplate.getForEntity(\"http://localhost/get/{id}\", UserEntity.class, map); UserEntity userEntity = responseEntity.getBody(); return userEntity;} 通过断点调试我们看下 返回的 responseEntity 的信息如图: 因此我们可以获取Http请求的全部信息. 但是,通常情况下我们并不想要Http请求的全部信息,只需要相应体即可.对于这种情况,RestTemplate提供了 getForObject() 方法用来只获取 响应体信息.getForObject 和 getForEntity 用法几乎相同,指示返回值返回的是 响应体,省去了我们 再去 getBody() . 测试: getForObject无参数的 getForObject 请求 12345678 //无参数的 getForObject 请求@RequestMapping(\"getAll2\")public List&lt;UserEntity&gt; getAll() { List&lt;UserEntity&gt; list = restTemplate.getForObject(\"http://localhost/getAll\", List.class); System.out.println(list.toString()); return list;} 有参数的 getForObject 请求,使用参数列表 12345678//有参数的 getForObject 请求@RequestMapping(\"get2/{id}\")public UserEntity getById(@PathVariable(name = \"id\") String id) { UserEntity userEntity = restTemplate.getForObject(\"http://localhost/get/{id}\", UserEntity.class, id); return userEntity;} 有参数的 get 请求,使用map封装请求参数 12345678910//有参数的 get 请求,使用map封装请求参数@RequestMapping(\"get3/{id}\")public UserEntity getById3(@PathVariable(name = \"id\") String id) { HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"id\",id); UserEntity userEntity = restTemplate.getForObject(\"http://localhost/get/{id}\", UserEntity.class, map); return userEntity;} Post请求了解了get请求后,Post请求就变得很简单了,我们可以看到post有如下方法: 测试: postForEntitypost 请求,保存 UserEntity 对像 1234567891011//post 请求,提交 UserEntity 对像@RequestMapping(\"saveUser\")public String save(UserEntity userEntity) { ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(\"http://localhost/save\", userEntity, String.class); String body = responseEntity.getBody(); return body;} 浏览器访问: http://localhost/saveUser?username=itguang&amp;password=123456&amp;age=20&amp;email=123@123.com我们再次断点调试,查看 responseEntity 中的信息: 有参数的 postForEntity 请求 123456789101112131415161718192021 // 有参数的 postForEntity 请求 @RequestMapping(\"saveUserByType/{type}\") public String save2(UserEntity userEntity,@PathVariable(\"type\")String type) {ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(\"http://localhost/saveByType/{type}\", userEntity, String.class, type); String body = responseEntity.getBody(); return body;}// 有参数的 postForEntity 请求,使用map封装@RequestMapping(\"saveUserByType2/{type}\")public String save3(UserEntity userEntity,@PathVariable(\"type\")String type) { HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"type\", type); ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(\"http://localhost/saveByType/{type}\", userEntity, String.class,map); String body = responseEntity.getBody(); return body;} 我们浏览器访问: localhost/saveUserByType/120?username=itguang&amp;password=123456&amp;age=20&amp;email=123@123.com 就会返回: 保存成功,type=120 对与其它请求方式,由于不常使用,所以这里就不再讲述.","link":"/2020/04/11/RestTemplate/"},{"title":"docker命令","text":"1&gt;.Docker镜像指令镜像检索Docker的镜像都放置在Docker官网的Docker Hub上，地址是https://registry.hub.docker.com。可在该网站搜索镜像,也可以用命令“docker search 镜像名”（如：docker search redis）检索。 镜像下载docker pull 镜像名 查看本地镜像列表docker images 删除镜像docker rmi image-id 删除所有镜像docker rmi $(docker images -q) 2&gt;.Docker容器指令运行镜像为容器docker run –name container-name -d image-name其中–name市委容器取个名称，-d表示detached，意味着执行完这句命令后控制台将不会被阻碍，可继续输入命令操作。如：docker run –name test-redis -d redis 查看运行中的容器列表docker ps通过下列命令可查看运行和停止状态的容器：docker ps -a 停止容器通过容器名称或容器ID停止容器docker stop container-name/container-id如：docker stop test-redis 启动容器通过容器名称或容器ID启动容器docker start container-name/container-id如：docker start test-redis 设置容器开机启动使用在Docker run的时候使用–restart参数来设置。no - container：不重启on-failure - container:退出状态非0时重启always:始终重启如：docker run –restart=always –name first-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 端口映射Docker容器中运行的软件所使用的端口，需要映射到当前主机的端口上才能访问。Docker的端口映射通过一个-p参数来实现。例如，我们将Redis容器的6379端口映射到本机的6378端口：docker run -d -p 6378:6379 –name port-redis redis 删除容器docker rm container-id 删除所有容器docker rm $(docker ps -a -q) 查看当前容器日志docker logs container-name/container-id如：docker logs port-redis 登陆容器运行中的容器其实是一个功能完备的Linux操作系统，所以我们可以像常规的系统一样登录并访问容器。我们可以使用如下命令，登录访问当前容器，登陆后我们可以在容器中进行常规的Linux系统操作命令，还可以使用exit命令退出登录：docker exec -it container-id/container-name bash","link":"/2020/04/09/docker%E5%91%BD%E4%BB%A4/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/20/hello-world/"},{"title":"linux命令大全","text":"1. 启动,关机,登入,登出相关命令登录：login登出：logout登出：exit停止系统：shutdown停止系统：halt重启动：reboot切断电源：poweroff把内存里的内容写入磁盘：sync安装lilo启动管理程序：lilo安装lilo启动管理程序：grub 2. Shell相关命令切换Shell：chsh显示命令履历：history设置命令别名：alias取消命令别名：unalias显示命令所在位置：which查询命令种类：type显示字符串或者变量内容：echo设置/显示Shell变量：set显示环境变量：printenv设置环境变量：export设置临时环境变量：env释放环境变量：unset设置环境变量：setenv释放环境变量：unsetenv执行文件当中的命令：source查询命令手册：man查询超文本命令手册：info显示命令简介：whatisapropos通过关键字查询手册：apropos 3. 用户管理相关命令切换到其他用户：su追加用户：useradd追加用户：adduser删除用户：userdel修改用户设置：usermod修改用户私人信息：chfn追加组：groupadd删除组：groupdel修改组设置：groupmod更改密码：passwd显示用户名：whoami显示登录用户帐号：logname显示所有登录用户信息：users查询登录用户信息：who查询登录用户信息：w显示指定用户的ID信息：id显示指定用户的所属组：groups显示指定用户的个人信息：finger开关与他人收发消息：mesg给其他用户发消息：write给所有用户发消息：wall和其他用户聊天：talk 4. 系统消息相关命令显示/设置当前时间：date显示系统运行时间：uptime显示机器的核心构架（如i386）：arch显示操作系统信息：uname显示终端名：tty显示登录/登出在履历：last显示非法登录信息：lastb显示当前键盘配置：dumpkeys变更键盘配置：loadkeys查询磁盘使用信息：df查询磁盘使用信息：du显示系统启动消息：dmesg保存输入输出到文件：script 5. 文件操作相关命令显示文件列表：ls显示目录树：tree显示当前路径：pwd更改当前路径：cd追加路径到目录堆栈：pushd从目录堆栈删除路径：popd显示目录堆栈的内容：dirs创建路径：mkdir删除路径：rmdir复制文件/目录：cp删除文件/目录：rm移动文件/目录，修改文件名：mv更改文件/目录的所有者：chown修改文件/目录的所有组：chgrp修改文件/目录的权限：chmod更改文件时间：touch建立文件/目录链接：ln查找文件：find显示文件存在的路径名：whereis查询文件种类：file查询文件大小：size 6. 文件编辑相关命令显示文件内容：cat输出到文件和屏幕：tee分屏显示文件内容：more分屏显示文件内容：less显示文件头部内容：head显示文件尾部内容：tail折叠显示长行：fold排列文件的行：sort比较文件内容：cmp显示文件差异：diff更改日语文件编码：nkf变更文件之后复制：dd统计文本单词数，文件大小等：wc分割文件：split以行连接文件：paste以字段连接文件：join查询文字：grep过滤重复部分显示文件内容：uniq替换文字：tr替换文字：sed 7. 压缩/解压缩相关命令压缩/解压缩文件：ar压缩/解压缩文件：tar压缩/解压缩文件：compress解压缩：uncompress压缩/解压缩文件：gzip解压缩：gunzip显示压缩文件的内容：zcat压缩/解压缩文件：lha把二进制文件编码为文本文件：uuencode把经过编码的文本文件还原为二进制文件：uudecode MS-DOS工具集[mtools]命令 显示文件列表：mdir 改变当前目录：mcd 新建目录：mmd 删除目录：mrd 删除目录树：mdeltree 复制文件：mcopy 删除文件：mdel 移动文件：mmove 更改文件或目录名：mren 修改文件属性：mattrib 显示文件内容：mtype 查询文件或目录大小：mdu 显示磁盘信息：minfo 以MS-DOS方式格式化磁盘：mformat 设置磁盘标签：mlabel 9. 控制外部设备相关命令mount上设备：mount解除已经mount上的设备：umount弹出（CD/DVD等）：eject格式化软盘：fdformat配置/显示硬盘分区：fdisk格式化磁盘分区：mkfs检查/修复磁盘错误：fsck打印到打印机：lpr中断打印任务：lprm显示打印任务的状态：lpq管理/控制打印任务：lpc显示/设定NIC配置：ifconfig 10. 进程及任务管理相关命令显示正在运行的进程：ps显示后台运行任务：jobs把任务切换到前台：fg把任务切换到后台：bg中止进程或任务：kill中止进程或任务：killall等待进程或任务的结束：wait设置定时执行任务：at显示尚未执行的任务：atq删除定时执行任务：atrm在系统负荷减轻的时候执行任务：batch改变优先度并执行任务：nice在后台执行任务，Logout之后也不退出：nohup休眠一定的时间：sleep 11. 网络管理相关命令显示当前网络连接状况：netstat显示/设置路由：route显示网络主机情况：host显示/设置当前主机的名字：hostname确认和远程机器的连接情况：ping显示路由信息：traceroute查询网上机器的登陆用户：rwho查询网上机器的系统运行时间：ruptime登陆到远程机器：rlogin用telnet登陆到远程机器：telnet给远程机器发送命令：rsh在远程机器之间复制文件：rcp收取邮件：mail发送邮件：sendmail确认邮件队列：mailq用ftp传输文件：ftp 12. 其他命令显示日历：cal清屏：clear编译C语言代码：gcc汇编：as计算：bcRedhat的包管理：rpmDebian的包管理：dpkgSlackware的包安装（删除命令则是removepkg）：installpkg配置 X 服务器：XF86Setup,turboxfg,Xconfigurator启动 X-Window 系统：startx","link":"/2020/04/09/linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"title":"mac按键图标","text":"Mac键盘图标与对应快捷按键 ⌘——Command () win键 ⌃ ——Control ctrl键 ⌥——Option (alt) ⇧——Shift ⇪——Caps Lock fn——功能键就是fn .m.h切换 ⌘+⌃ +↓or↑ 前进后退文本文件⌘+⌃ +←or→ 关闭当前文本文件⌘+⌃+w 自动排版代码 ⌃+i 左右缩进 ⌘+[or] 注释 ⌘+/ 查看名称定义，进入头文件 ⌘+鼠标左键 查看名称api文档 ⌥+鼠标左键 快捷键功能 Command A 全选Command C 拷贝Command V 粘贴Command X 文字剪切（不支持文件剪切）Command ，偏好设置Command W 关闭当前窗口Command Q 关闭当前程序Command Shift Q 退出所有程序并注销Command Option esc 强制退出应用程序，类似于win下的任务管理器Command N 新建当前程序的文件Command S 保存Command Shift S 另存为….（部分程序适用）Command H 隐藏当前程序（Boss Key）Command Option H 隐藏所有后台程序Control Shift 光盘推出键黑屏（没有Boss Key好用，一动就亮）Command P 打印Command Shift P 页面设置Command tab 切换到下一个应用程序Command Shift tab 切换到上一个应用程序Command ~ 在同一程序的不同窗口下切换，safari上网经常用Command M 最小化当前窗口Command Option F 有搜索栏的程序跳到搜索栏，如Preview(预览)的搜索栏，Safari的Google栏","link":"/2020/03/31/mac%E6%8C%89%E9%94%AE%E5%9B%BE%E6%A0%87/"},{"title":"springboot1","text":"关于Springboot-Mybatis无配置文件注解版的思考用过springboot后，我们发现，整个项目除了application.properties文件，其他配置文件，如mybatis-config.xml、mapper.xml都不需要，甚至数据库java配置类也不需要，非常的方便。 整个项目除了pom.xml文件和application.properties文件外，没有其他配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xz&lt;/groupId&gt; &lt;artifactId&gt;blog&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;blog&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;5.0.8.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL (JSP standard Tag Library) JSP 标准标签库 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt; 注意，这个scope需要被注释掉--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring Boot的JPA依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--在导入druid数据源时，也就是外部数据源，我们必须导入相关依赖，因此我尝试将springboot默认数据源的相关依赖也导入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.ibatis/ibatis-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ibatis&lt;/groupId&gt; &lt;artifactId&gt;ibatis-core&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动 - https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.1_3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- end --&gt; &lt;!--redis jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--注意此次必须要放在此目录下才能被访问到 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; --&gt; &lt;/build&gt;&lt;/project&gt; application.properties配置 application.properties文件内容主要是配置了下数据库连接信息（必须配置）以及tomcat server的端口号（默认是8080，如果没有修改tomcat端口号，这部分也是可以不用配置的），项目中application.properties文件配置内容如下: 123456 #mysql配置spring.datasource.url=jdbc:mysql://localhost:3306/ssmstu?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=bjtungircspring.datasource.driver-class-name=com.mysql.jdbc.Drivermybatis.typeAliasesPackage=com.tqh.demo.model 具体代码 接下来就可以直接写controller、mapper、model、service里面的java代码了 首先按model开始讲起： a、model—-Person.java 定义了一个POJO类12345678910111213141516171819202122232425262728293031323334353637383940414243packege ....import ....public class Person { private Integer id; private String name; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age ; }} DAO层设计—mapper—》UserMapper.java 是一个接口类，在springmvc框架中，我们是需要为每一个mapper类写xml配置文件，例如UserMapper.xml，该文件负责具体的mapper类中的方法实现，因此我们不需要写dao的实现，就可以直接在service里面直接调用dao的方法了,mybatis会默认把UserMapper.xml映射为dao的实现。 在springboot中，我们甚至不用创建UserMapper.xml文件，可以直接在UserMapper.java里面，添加注解进行dao层操作，然后在启动类里面添加@MapperScan(“com.xz.blog.mapper”) //包扫描，即可(不过我还是喜欢@mapper在每个mapper文件，感觉@MapperScan容易报错，老是扫描不到)。 UserMapper.java123456789101112131415161718192021222324252627282930313233343536373839@Mapperpublic interface UserMapper { /** * 方式1：使用注解编写SQL。 */ @Select(\"select * from t_user\") List&lt;User&gt; list(); /** * 方式2：使用注解指定某个工具类的方法来动态编写SQL. */ @SelectProvider(type = UserSqlProvider.class, method = \"listByUsername\") List&lt;User&gt; listByUsername(String username); /** * 延伸：上述两种方式都可以附加@Results注解来指定结果集的映射关系. * * PS：如果符合下划线转驼峰的匹配项可以直接省略不写。 */ @Results({ @Result(property = \"userId\", column = \"USER_ID\"), @Result(property = \"username\", column = \"USERNAME\"), @Result(property = \"password\", column = \"PASSWORD\"), @Result(property = \"mobileNum\", column = \"PHONE_NUM\") }) @Select(\"select * from t_user\") List&lt;User&gt; listSample(); /** * 延伸：无论什么方式,如果涉及多个参数,则必须加上@Param注解,否则无法使用EL表达式获取参数。 */ @Select(\"select * from t_user where username like #{username} and password like #{password}\") User get(@Param(\"username\") String username, @Param(\"password\") String password); @SelectProvider(type = UserSqlProvider.class, method = \"getBadUser\") User getBadUser(@Param(\"username\") String username, @Param(\"password\") String password);} UserService.java12345678910111213141516171819202122@Servicepublic class UserService { @Autowired public UserMapper userMapper; // 获取单个用户信息 @Transactional //添加事务管理 public Person selectUser(int id) { return userMapper.selectUser(id); } //获取所有的用户信息 @Transactional public ArrayList&lt;Person&gt; selectAllUser() { return userMapper.selectAllUser(); } } Controller层123456789101112131415161718192021222324252627282930313233343536//@RestController@Controller//@ResponseBody//testController返回的不是页面,Controller返回的是页面 testController=Controller + ResponseBodypublic class UserController { @Autowired private UserService userService; @RequestMapping(\"/showUser/{id}\") public String selectUser (@PathVariable int id,Model model){ model.addAttribute(\"name\", userService.selectUser(id).toString()); return \"greets\"; } @RequestMapping(\"/showUser/all\") public String selectAllUser(){ return userService.selectAllUser().toString(); } @RequestMapping(\"/name\") public String name() { System.out.println(\"============================================\"); return \"hello\"; } /** @RequestMapping(\"/greet\") public String greeting(@RequestParam(value = \"name\", required = false, defaultValue = \"World\") String name, Model model) { model.addAttribute(\"name\", name); return \"greets\"; } **/ } 理解@controller和@Restcontroller两个注解，简单可以这么理解：RestController返回的不是页面,Controller返回的是页面 RestController=Controller + ResponseBodyreturn “greets”后，springboot是怎么定位到页面的：springboot的页面默认是放在:templates下面的，查询时默认文件的后缀名是html,也就是说默认是支持html文件的，但是jsp文件是不推荐的，需要额外配置。默认前缀名是通过return返回的字符串进行查找，如果找到了，就直接返回该页面文件视图，否则就直接返回默认的页面。总结归纳：1、springboot+mybatis只需要application.properties文件就可以了，里面只需要配置下server.port（tomcat端口号，如果是8080，连该端口号也不需要配置），其次配置下mysql的连接属性. 2、springboot集成mybatis不需要mybatis-config.xml也不需要mapper.xml，也不需要相应的配置类(配置事务和数据源)。原因在于springboot提供的mybatis-spring-boot-starter，使用注解解决一切问题，注意一定要在启动类里面@MapperScan(“com.xz.blog.mapper”) //包扫描，否则注解会无效。（资料：[](https://www.cnblogs.com/shanheyongmu/p/6868669.html） 3、Spring boot不建议使用jsp开发web。而是推荐使用Thymeleaf来作为模板引擎开发web项目。 spring-boot项目静态文件目录：/src/java/resources/static spring-boot项目模板文件目录：/src/java/resources/templates html文件在/src/java/resources/templates下。 如果要使用jsp来开发web，需要自行配置。4、controller层，代码中注意理解@controller和@Restcontroller两个注解，简单可以这么理解： RestController返回的不是页面,Controller返回的是页面 RestController=Controller + ResponseBody","link":"/2020/03/21/springboot1/"},{"title":"springboot2","text":"spring data jpa方法命名规则 如果命名不正确会出现 Spring Data JPA: No property foo found for type BarNo property user found for type 1234public interface UserRepository extends JpaRepository&lt;User, Long&gt;{ User findByName(String userName);} 可以看出实体类字段是userName,而repository却是findByName!改为findByUserName就好了 参考https://blog.csdn.net/j080624/article/details/82559318 https://www.cnblogs.com/oxygenG/p/10057525.html","link":"/2020/03/21/springboot2/"},{"title":"springboot3","text":"SpringBoot之 session和拦截器 Session:在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。 最近同学小组做电商商城，需要跳转页面后，还能保持登录信息。未登录时， 除了访问登录界面和商品页面，其他的界面被访问的时候被拦截且返回到登录页面。网上搜了半天，大概可以通过session，jwt，shiro等，由于本项目只有一种角色不需要鉴权，所以只需session操作。 首先， 我们要创建一个存放session登录信息的工具类: 12345package com.ecommerce.web.util;public class ConstantUtils { public final static String USER_SESSION_KEY=\"USER\";} 然后， 当用户成功登录以后，将用户信息作为一个session对象存放起来。 12345678910111213141516171819package com.ecommerce.web.controller;@PostMapping(\"/login\")public Object login( @RequestParam(\"id\") int id, @RequestParam(\"password\") String password HttpServletRequest request) throws JSONException, NoFindException { if (userService.login(id, password)) { //如果成功了，聚合需要返回的信息 User user =userService.search(id); //在session里注入用户信息，之后网页请求时，头部带session，通过拦截器判断是否有用户信息 request.getSession().setAttribute(ConstantUtils.USER_SESSION_KEY,user); return displayUtil.result(displayUtil.secret(user),\"登录成功\"); } else return displayUtil.result(null,\"登录失败\");} 此时我们尚未添加拦截器， 登录以后可以在任何其他页面拿到session中的用户信息。 拦截器:上面的session实现了之后 ， 无论用户登录与否， 项目的页面是都可以访问的， 现在创建拦截器。(未登录不可访问除登录页面以外的其他页面). 首先，创建拦截器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.ecommerce.web.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.ecommerce.web.entity.User;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import com.ecommerce.web.util.ConstantUtils;@Componentpublic class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { User user = (User) request.getSession().getAttribute(ConstantUtils.USER_SESSION_KEY); //如果session中没有user，表示没登陆 if (user == null){ //这个方法返回false表示忽略当前请求，如果一个用户调用了需要登陆才能使用的接口，如果他没有登陆这里会直接忽略掉 //当然你可以利用response给用户返回一些提示信息，告诉他没登陆 response.sendRedirect(request.getContextPath()+\"/\"); //到时把这改成登录页面的地址 return false; }else { return true; //如果session里有user，表示该用户已经登陆，放行，用户即可继续调用自己需要的接口 } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // TODO Auto-generated method stub HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // TODO Auto-generated method stub HandlerInterceptor.super.afterCompletion(request, response, handler, ex); }} 然后注入拦截器 ( addPathPatterns 是指为哪些地址添加拦截器， /** 是所有。excludePathPatterns 是指不需要拦截器的地址， 这里除了登录 和退出登录 ) 123456789101112131415161718192021222324252627package com.ecommerce.web.config;import com.ecommerce.web.interceptor.LoginInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfigurer implements WebMvcConfigurer { @Autowired LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // TODO Auto-generated method stub // addPathPatterns(\"/**\") 表示拦截所有的请求， // excludePathPatterns(\"/login\", \"/register\") 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问 registry.addInterceptor(loginInterceptor) .addPathPatterns(\"/user/**\") //我在controller层中把有关用户的controller在类上注释@RequestMapping(\"/user\") .excludePathPatterns(\"/user/register\",\"/user/login\"); }} 这样，当我们未登录的时候，就会重定向到”/(登录)” 地址下面。 实现了登录拦截。 退出登陆:即销毁session 12345@PostMapping(\"/logout\")public Object logout(HttpServletRequest request){ request.getSession().removeAttribute(ConstantUtils.USER_SESSION_KEY); return displayUtil.result(null,\"退出成功\");} postman测试后有效 [项目源码]（https://github.com/gcs104/e-commerceWeb）","link":"/2020/03/21/springboot3/"},{"title":"在linux上部署springboot项目","text":"##springboot在linux中运行 ###单次运行 在idea中找到maven可视化界面，双击package打包jar文件 打开terminal，左上角shell-&gt;new remote connection-&gt;选sftp-&gt;user填root，下面填sftp root@ip地址（本人sftp root@47.99.205.75）-&gt;上传文件格式put 本地地址 远程文件要放的地址（usr/lib） 在linux中提前已经用Navicat创建数据库，只需 1java -jar /usr/lib/项目jar名.jar --spring.profiles.active=prod 即可在本地用ip地址：端口号访问 当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出 以上方法在关闭进程后项目也停了 ###持续运行 1nohup java -jar /usr/lib/项目jar名.jar &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行 当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。 1nohup java -jar XXX.jar &gt;temp.txt &amp; 解释下 &gt;temp.txt command &gt;out.file command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。 可通过jobs命令查看后台运行任务 1jobs 那么就会列出所有后台执行的作业，并且每个作业前面都有个编号。如果想将某个作业调回前台控制，只需要 fg + 编号即可。 1fg 23 通过lsof查询进程 1lsof -i:端口号 如果提示command not found，先下载lsof 1yum install lsof a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分 注： 用ps -def | grep查找进程很方便，最后一行总是会grep自己 用grep -v参数可以将grep命令排除掉 1ps -aux|grep chat.js 结束nohup进程， 1kill -9 进程号(注意是进程号不是端口号)","link":"/2020/04/09/%E5%9C%A8linux%E4%B8%8A%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"title":"springboot4","text":"mybatis中使用Java8的日期LocalDate、LocalDateTime 在实体Entity里面，可以使用java.sql.Date、java.sql.Timestamp、java.util.Date来映射到数据库的date、timestamp、datetime等字段 但是，java.sql.Date、java.sql.Timestamp、java.util.Date这些类都不好用，很多方法都过时了。 现在改用LocalDate、LocalTime、LocalDateTime 非常好用 默认的情况下，在mybatis里面不支持java8的时间、日期。直接使用，会报如下错误 12345678910Caused by: java.lang.IllegalStateException: No typehandler found for property createTime at org.apache.ibatis.mapping.ResultMapping$Builder.validate(ResultMapping.java:151) at org.apache.ibatis.mapping.ResultMapping$Builder.build(ResultMapping.java:140) at org.apache.ibatis.builder.MapperBuilderAssistant.buildResultMapping(MapperBuilderAssistant.java:382) at org.apache.ibatis.builder.xml.XMLMapperBuilder.buildResultMappingFromContext(XMLMapperBuilder.java:378) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:280) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:252) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElements(XMLMapperBuilder.java:244) at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:116) ... 81 common frames omitted 解决方法如下： 直接加入如下依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt; 以上仅在mybatis 3.4.0版本中测试有效 如果使用的mybatis版本低于3.4.0，则还需要配置如下 123456789&lt;typeHandlers&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.InstantTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.LocalDateTimeTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.LocalDateTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.LocalTimeTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.OffsetDateTimeTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.OffsetTimeTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.ZonedDateTimeTypeHandler\" /&gt;&lt;/typeHandlers&gt;","link":"/2020/03/21/springboot4/"},{"title":"springboot5","text":"在springboot中，普通类注入dao层报错:Autowired members must be defined in the valid spring bean (@Component/@Service,etc.) less… (Ctrl+F1) Checks autowiring problems in a bean class. 在该类中加入注解@Component可以解决 但是实际使用该类时还是报查询数据库空指针异常，仔细检查代码都没问题，数据库中也有相应数据，最后发现是调用该类时不是注入的而是new了实例。 我一直是以为Mapper的注入出了问题，，结果恰恰不是，问题出在了该类上 ，因为在LotteryUtil里面是通过注入的方式获得Mapper的实例化对象的，所以LotteryUtil对象的获得也应该采用注入的方式（前后一致），这样才能得到这个类扫面后创建的Mapper的实例化对象（可参考源码）。如果是new 出来的LotteryUtli对象的话，它的中的@Autowired注解是不起作用的，因为自己new出来的对象不是spring容器中的，无法使用注入，因此Mapper对象当然为NULL啦。 还有最让人头疼的就是，开发工具昨天抽筋了，明明之前已经写对了，但是编译不及时，依然报错…….重启之后再打开，莫名的又编译成功了，，所以，睡一觉还是有这么点好处的(玩笑话），clean之后再执行编译，其实也是可以的。","link":"/2020/04/07/springboot5/"},{"title":"网址记录","text":"##记录好玩有用网址 ###学习 nohup和&amp;后台运行，进程查看及终止 打包部署SpringBoot项目 yapi接口开发文档 java核心知识大全 springboot学习 开源书籍 娱乐 诗歌生成器","link":"/2020/04/09/%E7%BD%91%E5%9D%80%E8%AE%B0%E5%BD%95/"},{"title":"解决网页文字无法选中复制","text":"解决网页文字无法选中复制 我们在查看一些网页时会遇到不能复制的问题，或者鼠标无法选中文字，导致不能复制。 如这个下面网页 解决：按f12，点击console控制台，输入以下代码后回车即可 1234var eles = document.getElementsByTagName('*');for (var i = 0; i &lt; eles.length; i++) { eles[i].style.userSelect = 'text';}","link":"/2020/04/03/%E8%A7%A3%E5%86%B3%E7%BD%91%E9%A1%B5%E6%96%87%E5%AD%97%E6%97%A0%E6%B3%95%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6/"},{"title":"简历.md","text":"王宏州简历 联系方式 手机：18857608326 Email：1195687131@qq.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G） QQ/微信号：1195687131 个人信息 王宏州/男/2001 本科/南京邮电大学/软件工程嵌入式培养专业 技术博客：https://whz11.github.io/ Github：https://github.com/whz11 项目经历抽奖系统第一个springboot项目，学会了springboot基本结构，但相关技术方面只是依葫芦画瓢。 circle对springboot各个层功能有了明确认识，解决了第一个项目上不理解的地方，对统一封装返回有了认识 电影推荐系统参加脑洞周程序设计比赛时写的， 基于每日天气设计的天气随机算法（滑稽）定时推荐电影至用户邮箱（本项目采用qq邮箱）， 影片源采用之前爬取的豆瓣250名电影排行榜，天气源http://wthrcdn.etouch.cn/weather_mini?city=&quot; “,每日推送情况和影片源可在后台，查看端口号8081，默认页面是history可以通过影片库按钮跳转到影片库页面，页面右上角有天气插件。 项目后台:link 简易电商网站负责用户模块，登陆模块，学习拦截器和sessiion 人事管理系统负责登陆模块，社团部门管理员模块 个人对后端理解因为现在只会springboot一个框架，会有先入为主的感觉，所以对后端不太好过多理解，之后会学习不同框架和语言如php，到时会从中归纳出共通点 致谢感谢您花时间阅读我的简历。","link":"/2020/07/28/%E7%AE%80%E5%8E%86-md/"}],"tags":[{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"百宝箱","slug":"百宝箱","link":"/tags/%E7%99%BE%E5%AE%9D%E7%AE%B1/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"简历","slug":"简历","link":"/tags/%E7%AE%80%E5%8E%86/"}],"categories":[]}