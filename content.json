{"pages":[],"posts":[{"title":"dfs","text":"DFS 深度优先搜索 深度优先搜索算法（英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。 123456789101112131415161718192021int check(参数){ if(满足条件) return 1; return 0;}void dfs(int step){ 判断边界 { 相应操作 } 尝试每一种可能 { 满足check条件 标记 继续下一步dfs(step+1) 恢复初始状态（回溯的时候要用到） }} 1、全排列问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;string.h&gt;int n;char a[15];char re[15];int vis[15];//假设有n个字符要排列，把他们依次放到n个箱子中//先要检查箱子是否为空，手中还有什么字符，把他们放进并标记。//放完一次要恢复初始状态，当到n+1个箱子时，一次排列已经结束void dfs(int step){ int i; if(step==n+1)//判断边界 { for(i=1;i&lt;=n;i++) printf(\"%c\",re[i]); printf(\"\\n\"); return ; } for(i=1;i&lt;=n;i++)//遍历每一种情况 { if(vis[i]==0)//check满足 { re[step]=a[i]; vis[i]=1;//标记 dfs(step+1);//继续搜索 vis[i]=0;//恢复初始状态 } } return ;}int main(void){ int T; scanf(\"%d\",&amp;T); getchar(); while(T--) { memset(a,0,sizeof(a)); memset(vis,0,sizeof(vis));//对存数据的数组分别初始化 scanf(\"%s\",a+1); n=strlen(a+1); dfs(1);//从第一个箱子开始 } return 0;}//方法2class Solution {public: int n; vector&lt;int&gt; vis; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; vec; void dfs(int cur,vector&lt;int&gt; &amp;nums){ if(cur==n) { res.push_back(vec); return ; } for(int i=0;i&lt;nums.size();i++){ if(!vis[i]){ vec[i]=nums[cur]; vis[i]=1; dfs(cur+1,nums); vis[i]=0; } } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { n=nums.size(); vis=vector&lt;int&gt;(n); vec=vector&lt;int&gt;(n); dfs(0,nums); return res; }};","link":"/2020/03/21/dfs/"},{"title":"springboot2","text":"spring data jpa方法命名规则 如果命名不正确会出现 Spring Data JPA: No property foo found for type BarNo property user found for type 1234public interface UserRepository extends JpaRepository&lt;User, Long&gt;{ User findByName(String userName);} 可以看出实体类字段是userName,而repository却是findByName!改为findByUserName就好了 参考https://blog.csdn.net/j080624/article/details/82559318 https://www.cnblogs.com/oxygenG/p/10057525.html","link":"/2020/03/21/springboot2/"},{"title":"springboot1","text":"关于Springboot-Mybatis无配置文件注解版的思考用过springboot后，我们发现，整个项目除了application.properties文件，其他配置文件，如mybatis-config.xml、mapper.xml都不需要，甚至数据库java配置类也不需要，非常的方便。 整个项目除了pom.xml文件和application.properties文件外，没有其他配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xz&lt;/groupId&gt; &lt;artifactId&gt;blog&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;blog&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;5.0.8.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL (JSP standard Tag Library) JSP 标准标签库 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt; 注意，这个scope需要被注释掉--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring Boot的JPA依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--在导入druid数据源时，也就是外部数据源，我们必须导入相关依赖，因此我尝试将springboot默认数据源的相关依赖也导入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.ibatis/ibatis-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ibatis&lt;/groupId&gt; &lt;artifactId&gt;ibatis-core&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动 - https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.1_3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- end --&gt; &lt;!--redis jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--注意此次必须要放在此目录下才能被访问到 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; --&gt; &lt;/build&gt;&lt;/project&gt; application.properties配置 application.properties文件内容主要是配置了下数据库连接信息（必须配置）以及tomcat server的端口号（默认是8080，如果没有修改tomcat端口号，这部分也是可以不用配置的），项目中application.properties文件配置内容如下: 123456 #mysql配置spring.datasource.url=jdbc:mysql://localhost:3306/ssmstu?useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=bjtungircspring.datasource.driver-class-name=com.mysql.jdbc.Drivermybatis.typeAliasesPackage=com.tqh.demo.model 具体代码 接下来就可以直接写controller、mapper、model、service里面的java代码了 首先按model开始讲起： a、model—-Person.java 定义了一个POJO类12345678910111213141516171819202122232425262728293031323334353637383940414243packege ....import ....public class Person { private Integer id; private String name; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age ; }} DAO层设计—mapper—》UserMapper.java 是一个接口类，在springmvc框架中，我们是需要为每一个mapper类写xml配置文件，例如UserMapper.xml，该文件负责具体的mapper类中的方法实现，因此我们不需要写dao的实现，就可以直接在service里面直接调用dao的方法了,mybatis会默认把UserMapper.xml映射为dao的实现。 在springboot中，我们甚至不用创建UserMapper.xml文件，可以直接在UserMapper.java里面，添加注解进行dao层操作，然后在启动类里面添加@MapperScan(“com.xz.blog.mapper”) //包扫描，即可(不过我还是喜欢@mapper在每个mapper文件，感觉@MapperScan容易报错，老是扫描不到)。 UserMapper.java123456789101112131415161718192021222324252627282930313233343536373839@Mapperpublic interface UserMapper { /** * 方式1：使用注解编写SQL。 */ @Select(\"select * from t_user\") List&lt;User&gt; list(); /** * 方式2：使用注解指定某个工具类的方法来动态编写SQL. */ @SelectProvider(type = UserSqlProvider.class, method = \"listByUsername\") List&lt;User&gt; listByUsername(String username); /** * 延伸：上述两种方式都可以附加@Results注解来指定结果集的映射关系. * * PS：如果符合下划线转驼峰的匹配项可以直接省略不写。 */ @Results({ @Result(property = \"userId\", column = \"USER_ID\"), @Result(property = \"username\", column = \"USERNAME\"), @Result(property = \"password\", column = \"PASSWORD\"), @Result(property = \"mobileNum\", column = \"PHONE_NUM\") }) @Select(\"select * from t_user\") List&lt;User&gt; listSample(); /** * 延伸：无论什么方式,如果涉及多个参数,则必须加上@Param注解,否则无法使用EL表达式获取参数。 */ @Select(\"select * from t_user where username like #{username} and password like #{password}\") User get(@Param(\"username\") String username, @Param(\"password\") String password); @SelectProvider(type = UserSqlProvider.class, method = \"getBadUser\") User getBadUser(@Param(\"username\") String username, @Param(\"password\") String password);} UserService.java12345678910111213141516171819202122@Servicepublic class UserService { @Autowired public UserMapper userMapper; // 获取单个用户信息 @Transactional //添加事务管理 public Person selectUser(int id) { return userMapper.selectUser(id); } //获取所有的用户信息 @Transactional public ArrayList&lt;Person&gt; selectAllUser() { return userMapper.selectAllUser(); } } Controller层123456789101112131415161718192021222324252627282930313233343536//@RestController@Controller//@ResponseBody//testController返回的不是页面,Controller返回的是页面 testController=Controller + ResponseBodypublic class UserController { @Autowired private UserService userService; @RequestMapping(\"/showUser/{id}\") public String selectUser (@PathVariable int id,Model model){ model.addAttribute(\"name\", userService.selectUser(id).toString()); return \"greets\"; } @RequestMapping(\"/showUser/all\") public String selectAllUser(){ return userService.selectAllUser().toString(); } @RequestMapping(\"/name\") public String name() { System.out.println(\"============================================\"); return \"hello\"; } /** @RequestMapping(\"/greet\") public String greeting(@RequestParam(value = \"name\", required = false, defaultValue = \"World\") String name, Model model) { model.addAttribute(\"name\", name); return \"greets\"; } **/ } 理解@controller和@Restcontroller两个注解，简单可以这么理解：RestController返回的不是页面,Controller返回的是页面 RestController=Controller + ResponseBodyreturn “greets”后，springboot是怎么定位到页面的：springboot的页面默认是放在:templates下面的，查询时默认文件的后缀名是html,也就是说默认是支持html文件的，但是jsp文件是不推荐的，需要额外配置。默认前缀名是通过return返回的字符串进行查找，如果找到了，就直接返回该页面文件视图，否则就直接返回默认的页面。总结归纳：1、springboot+mybatis只需要application.properties文件就可以了，里面只需要配置下server.port（tomcat端口号，如果是8080，连该端口号也不需要配置），其次配置下mysql的连接属性. 2、springboot集成mybatis不需要mybatis-config.xml也不需要mapper.xml，也不需要相应的配置类(配置事务和数据源)。原因在于springboot提供的mybatis-spring-boot-starter，使用注解解决一切问题，注意一定要在启动类里面@MapperScan(“com.xz.blog.mapper”) //包扫描，否则注解会无效。（资料：[](https://www.cnblogs.com/shanheyongmu/p/6868669.html） 3、Spring boot不建议使用jsp开发web。而是推荐使用Thymeleaf来作为模板引擎开发web项目。 spring-boot项目静态文件目录：/src/java/resources/static spring-boot项目模板文件目录：/src/java/resources/templates html文件在/src/java/resources/templates下。 如果要使用jsp来开发web，需要自行配置。4、controller层，代码中注意理解@controller和@Restcontroller两个注解，简单可以这么理解： RestController返回的不是页面,Controller返回的是页面 RestController=Controller + ResponseBody","link":"/2020/03/21/springboot1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/20/hello-world/"},{"title":"springboot3","text":"SpringBoot之 session和拦截器 Session:在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在 Session 对象中。 最近同学小组做电商商城，需要跳转页面后，还能保持登录信息。未登录时， 除了访问登录界面和商品页面，其他的界面被访问的时候被拦截且返回到登录页面。网上搜了半天，大概可以通过session，jwt，shiro等，由于本项目只有一种角色不需要鉴权，所以只需session操作。 首先， 我们要创建一个存放session登录信息的工具类: 12345package com.ecommerce.web.util;public class ConstantUtils { public final static String USER_SESSION_KEY=\"USER\";} 然后， 当用户成功登录以后，将用户信息作为一个session对象存放起来。 12345678910111213141516171819package com.ecommerce.web.controller;@PostMapping(\"/login\")public Object login( @RequestParam(\"id\") int id, @RequestParam(\"password\") String password HttpServletRequest request) throws JSONException, NoFindException { if (userService.login(id, password)) { //如果成功了，聚合需要返回的信息 User user =userService.search(id); //在session里注入用户信息，之后网页请求时，头部带session，通过拦截器判断是否有用户信息 request.getSession().setAttribute(ConstantUtils.USER_SESSION_KEY,user); return displayUtil.result(displayUtil.secret(user),\"登录成功\"); } else return displayUtil.result(null,\"登录失败\");} 此时我们尚未添加拦截器， 登录以后可以在任何其他页面拿到session中的用户信息。 拦截器:上面的session实现了之后 ， 无论用户登录与否， 项目的页面是都可以访问的， 现在创建拦截器。(未登录不可访问除登录页面以外的其他页面). 首先，创建拦截器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.ecommerce.web.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.ecommerce.web.entity.User;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import com.ecommerce.web.util.ConstantUtils;@Componentpublic class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { User user = (User) request.getSession().getAttribute(ConstantUtils.USER_SESSION_KEY); //如果session中没有user，表示没登陆 if (user == null){ //这个方法返回false表示忽略当前请求，如果一个用户调用了需要登陆才能使用的接口，如果他没有登陆这里会直接忽略掉 //当然你可以利用response给用户返回一些提示信息，告诉他没登陆 response.sendRedirect(request.getContextPath()+\"/\"); //到时把这改成登录页面的地址 return false; }else { return true; //如果session里有user，表示该用户已经登陆，放行，用户即可继续调用自己需要的接口 } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // TODO Auto-generated method stub HandlerInterceptor.super.postHandle(request, response, handler, modelAndView); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // TODO Auto-generated method stub HandlerInterceptor.super.afterCompletion(request, response, handler, ex); }} 然后注入拦截器 ( addPathPatterns 是指为哪些地址添加拦截器， /** 是所有。excludePathPatterns 是指不需要拦截器的地址， 这里除了登录 和退出登录 ) 123456789101112131415161718192021222324252627package com.ecommerce.web.config;import com.ecommerce.web.interceptor.LoginInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class WebConfigurer implements WebMvcConfigurer { @Autowired LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // TODO Auto-generated method stub // addPathPatterns(\"/**\") 表示拦截所有的请求， // excludePathPatterns(\"/login\", \"/register\") 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问 registry.addInterceptor(loginInterceptor) .addPathPatterns(\"/user/**\") //我在controller层中把有关用户的controller在类上注释@RequestMapping(\"/user\") .excludePathPatterns(\"/user/register\",\"/user/login\"); }} 这样，当我们未登录的时候，就会重定向到”/(登录)” 地址下面。 实现了登录拦截。 退出登陆:即销毁session 12345@PostMapping(\"/logout\")public Object logout(HttpServletRequest request){ request.getSession().removeAttribute(ConstantUtils.USER_SESSION_KEY); return displayUtil.result(null,\"退出成功\");} postman测试后有效 [项目源码]（https://github.com/gcs104/e-commerceWeb）","link":"/2020/03/21/springboot3/"},{"title":"springboot4","text":"mybatis中使用Java8的日期LocalDate、LocalDateTime 在实体Entity里面，可以使用java.sql.Date、java.sql.Timestamp、java.util.Date来映射到数据库的date、timestamp、datetime等字段 但是，java.sql.Date、java.sql.Timestamp、java.util.Date这些类都不好用，很多方法都过时了。 现在改用LocalDate、LocalTime、LocalDateTime 非常好用 默认的情况下，在mybatis里面不支持java8的时间、日期。直接使用，会报如下错误 12345678910Caused by: java.lang.IllegalStateException: No typehandler found for property createTime at org.apache.ibatis.mapping.ResultMapping$Builder.validate(ResultMapping.java:151) at org.apache.ibatis.mapping.ResultMapping$Builder.build(ResultMapping.java:140) at org.apache.ibatis.builder.MapperBuilderAssistant.buildResultMapping(MapperBuilderAssistant.java:382) at org.apache.ibatis.builder.xml.XMLMapperBuilder.buildResultMappingFromContext(XMLMapperBuilder.java:378) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:280) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElement(XMLMapperBuilder.java:252) at org.apache.ibatis.builder.xml.XMLMapperBuilder.resultMapElements(XMLMapperBuilder.java:244) at org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XMLMapperBuilder.java:116) ... 81 common frames omitted 解决方法如下： 直接加入如下依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-typehandlers-jsr310&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt;&lt;/dependency&gt; 以上仅在mybatis 3.4.0版本中测试有效 如果使用的mybatis版本低于3.4.0，则还需要配置如下 123456789&lt;typeHandlers&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.InstantTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.LocalDateTimeTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.LocalDateTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.LocalTimeTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.OffsetDateTimeTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.OffsetTimeTypeHandler\" /&gt; &lt;typeHandler handler=\"org.apache.ibatis.type.ZonedDateTimeTypeHandler\" /&gt;&lt;/typeHandlers&gt;","link":"/2020/03/21/springboot4/"},{"title":"mac按键图标","text":"Mac键盘图标与对应快捷按键 ⌘——Command () win键 ⌃ ——Control ctrl键 ⌥——Option (alt) ⇧——Shift ⇪——Caps Lock fn——功能键就是fn .m.h切换 ⌘+⌃ +↓or↑ 前进后退文本文件⌘+⌃ +←or→ 关闭当前文本文件⌘+⌃+w 自动排版代码 ⌃+i 左右缩进 ⌘+[or] 注释 ⌘+/ 查看名称定义，进入头文件 ⌘+鼠标左键 查看名称api文档 ⌥+鼠标左键 快捷键功能 Command A 全选Command C 拷贝Command V 粘贴Command X 文字剪切（不支持文件剪切）Command ，偏好设置Command W 关闭当前窗口Command Q 关闭当前程序Command Shift Q 退出所有程序并注销Command Option esc 强制退出应用程序，类似于win下的任务管理器Command N 新建当前程序的文件Command S 保存Command Shift S 另存为….（部分程序适用）Command H 隐藏当前程序（Boss Key）Command Option H 隐藏所有后台程序Control Shift 光盘推出键黑屏（没有Boss Key好用，一动就亮）Command P 打印Command Shift P 页面设置Command tab 切换到下一个应用程序Command Shift tab 切换到上一个应用程序Command ~ 在同一程序的不同窗口下切换，safari上网经常用Command M 最小化当前窗口Command Option F 有搜索栏的程序跳到搜索栏，如Preview(预览)的搜索栏，Safari的Google栏","link":"/2020/03/31/mac%E6%8C%89%E9%94%AE%E5%9B%BE%E6%A0%87/"},{"title":"java面向对象2","text":"","link":"/2020/04/03/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/"},{"title":"java面向对象3","text":"","link":"/2020/04/03/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13/"},{"title":"java面向对象1","text":"java面向对象 面向对象入门Java 是一门面向对象的编程语言，现在让我们了解一下什么是面向对象。这个名次听起来比较高级，和它相对应的是面向结构化的编程，我们在这里不花时间去讨论什么是面向结构化的，感兴趣的同学可以自己去查询一下。 我们学习过 Java 基础语言后会知道，在 Java 中对象其实就是一个 Class（类），在 Java 世界中所有的程序都是由 Class（对象、类） 组成的。为了更好的理解对象这件事，在编程世界里有一个专门的图形表示的语言来管理和维护对象，这个语言就是 UML 。 1997 年，对象管理组织（Object Management Group，OMG）发布了统一建模语言（Unified Modeling Language，UML）。UML 的目标之一就是为开发团队提供标准、通用的面向对象设计语言。UML 提供了一套图形标准，通过使用 UML 可以让编程人员能够阅读和交流系统架构图、设计图，就好比建筑工人看施工图来施工一样。 谈到这里，我自己的亲身经历正好佐证了这一点 几年前我在装修自己房子的时候受益颇多，我很容易理解设计师的意图以及对照着设计图形和工人进行交流（大家知道其实和装修工人沟通是非常困难的一件事，但是有了施工图就变的格外容易了，因为合格的装修工人都会看懂设计图的） 在面向对象中，只要我们熟练的运用 UML 其实开发代码会变的格外容易，到目前为止领域驱动开发也是最重要的一个开发方式，因为我们可以把对象转化为图形，看图会比看代码更容易理解，所以想要理解面向对象，我们会先从 UML 图形开始。现在先让我们看一下 UML 图形中的类框图（Class Diagram） 请注意，UML 不是只针对 Java 语言的，它适合于所有编程语言，所以学会这个是一件非常棒的体验。 掌握 UML 技术对于掌握面向对象是个非常大的助力，因为初学者一般来说都比较缺少抽象能力，而面向对象的核心工作就是抽象和封装，我们借助图形可以帮助我们训练抽象能力。 我们通过 QQ 群这个案例来初步了解类框图（Class Diagram）,首先我们看一下QQ群的页面，大家看一看 QQ群大部分人应该是比较熟悉的哦，如果用 Java 对象该如何表示呢？我们可以再看一下下图：UML类图 我们翻译一下上图哦，这个图转化成 Java 代码就是： 123456789101112131415161718192021package com.qq.model;/** * 群对象，封装了群的基础数据 */public class Group{ //群唯一的ID String id; //群号 String groupNo; //群图标 String icon; //群名称 String name; //群公告 String notice; //群简介 String desc; // 群成员 ArrayList&lt;User&gt; users;} 这里还有个 User 对象，我们暂时先不管它，在后面的课程中我们会通过对象关系介绍这个知识点。 通过上面的比较大家应该会发现看图比看代码是不是很容易清晰一点？ 类关联关系当我们能看明白 UML 类图的时候，我们就进入了编程语言从入门到进阶的阶段，接下来我们就要结合 UML 类图来逐步深入了解面向对象。 我们为什么反复强调面向对象呢？那是因为 Java 是面向对象的语言，在真实的世界里，所有的事物都可以用对象来表示，比如说学校、医院、商场、电影、音乐等等这些都可以用计算机来模拟出来，我们一般会把这些事物称为领域。编程的很多工作就是解决各种各样的问题领域 在阿里巴巴工作中也特别格外的看中解决问题的能力，因为编程的所有行为都是围绕着问题来展开的，如果没有问题也就不需要编程了。编程的复杂度会跟随问题领域的复杂而变的更复杂，所以我们鼓励更多人尽可能的去深入一些更有深度的问题领域，比如说电子商务、在线教育、社交、移动支付、人工智能等领域 继续说面向对象这件事，对象是对问题领域中事物的抽象。请大家记住抽象这个词，因为在以后的生涯当中，抽象这个词会非常高频的出现，可以说编程思维最最核心的一点就是抽象能力。 抽象就是把事物变成编程语言的过程，举个例子: 大学生信息可以抽象为Student对象，在 Java 中我们就可以创建一个 class Student 大学专业可以抽象为Major对象，在 Java 中我们就可以创建一个 class Major 现在我们分析一下大学生和专业这两个对象。 大学生这个对象一般会有如下的属性（主要的）： ID 主键 名称 性别 学号 学校名称 入学时间 手机号码 专业 专业这个对象也有几个通用的属性 ID(主键) 名称 是否招生 （有些专业会被关闭掉） 关于ID 主键这个知识我们需要强调一下，ID 主键用于表示全局唯一的记录，举个例子来理解一下ID 主键的重要性：我们有的时候会更换手机号码，手机号码到了一定的时间就会被运营商卖给另外一个人。如果没有 ID 主键就会发现这时候无法区分手机号到底是谁的了，这就全乱套啦。所以这时候我们会用一个单独的属性来表示唯一的数据，这个属性我们多数情况下都命名位 id，所以如果以后我们看到studentId、userId等这样的内容你应该知道它指的就是这条记录的主键。以后我们在学习数据库的时候还会继续学习到主键，实际上以后你会发现所有知识都是相同的 看到这里，我们再来总结一下对象的特性： 1. 万物皆对象正如上面所说，所有的事物都可以抽象成对象。随着我们的视野和抽象能力的提升，大家对这句话的理解会逐步深刻（新手运用抽象还是比较难的，这也是正常的） 2. 每个对象都是唯一的世界上不存在一摸一样的人，所以我们在编程语言中我们抽象出来的对象也是唯一的，例如学生张三、学生李四的英语四级证书都是唯一的对象。 需要注意：对象的唯一是指的类实例化后的每个实例都是唯一的，对于相同事物抽象后的类可以是相同的 3. 对象具备属性和方法每一个对象都拥有自己的属性定义和值，加上我们前面学习过的方法，那么属性+方法对象就是完整的了。 现在我们把上面的大学生和专业这两个对象用 UML 图来表示一下。请记住一图胜千言，看图过看代码 细心的你应该发现了这两个类之间多了一个线条 这个线条代表了对象之间关联关系，这也是我们学习到的第一个对象关系。关联关系是使用最多的关系，它代表着箭头左边的对象关联了右边的对象。 在上面的图中，代表着类Student 通过major这个属性关联了类Major,大家可以仔细看看图，初次看图还是不习惯的，多看几次就好了，要知道不管多复杂的程序都是由这些设计图开始的。 类之间的关系总共有： 关联 依赖 聚集 泛化 实现 访问控制修饰符面向对象的基本思想之一是封装实现细节并且公开接口，在 Java 语言中采用了访问控制修饰符来控制类，以及类的方法和变量的访问权限，从而达到隐藏实现细节只暴露接口的能力。 这个概念不是特别形象，不容易理解，我觉得大家可以把这个知识当作权限来理解，不同的修饰符具备不同的权限，我们只要记住权限的范围就好了，从本节课开始，我们的代码都会运用起来这个知识啦，多看几次也就记住啦， 访问控制分为4种级别： 公开级别：用 public 修饰，对外公开 受保护级别：用 protected 修饰，向子类及同一个包中的类公开 默认级别：没有访问修饰符，向同一个包中的类公开 私有级别：用 private 修饰，只有类本身可以访问，不对外公开 可以详细看下面的表格 修饰符 同类 同包 不同的包 public 有权限 有权限 有权限 protected 有权限 有权限 无权限 默认 有权限 有权限 无权限 private 有权限 无权限 无权限 了解了这些规则以后，我们就具体看看代码怎么写？我们在两个场景上会运用到访问控制修饰符 1. 类我们在创建类的时候，可以选择public和默认这两种，至于 protected 和 private 这两个是不允许使用的。不过默认情况下，我们都是创建 public 的 class。比如： 依照这个规范，下面的代码也是正确的，因为没有修饰符就是默认修饰符 123class Hello{} 2. 类的方法/实例变量我们在开始学习 Java 语言的时候，我们都选择使用了public修饰符来创建方法和对象，现在我们应该了解这里的public 是啥意思呢了，比如下面的代码 一般情况下类的成员变量（属性）就叫做实例变量 12345678910public class Hello { // 声明一个公开访问的字符串类型实例变量 public String msg = &quot;Hello&quot;; // 声明一个公开访问的方法 public String say(String word){ return msg + word; }} 其实大家对比应该会发现，不管是声明类、方法、实例变量第一个关键字就是在描述我们使用哪种修饰符，请记住这个语法的规范。其实大家已经不陌生了，这里只是让大家明白这个代码的内在含义。 123456789public class Hello { // 声明一个公开访问的字符串类型类变量 public String msg = &quot;Hello&quot;; // 声明一个私有访问的方法 private String say(String word){ return msg + word; }} 所以如果我们声明了一个私有方法，那么除了在类中可以调用，其他的地方都不可以调用的，规则如上面所说的一样。这意味着：如果我们想屏蔽代码细节，我们可以把具体的方法或者变量声明为私有的权限范围。 现在我们继续来了解一下 UML 类图中如何表示修饰符的，因为面向对象离不开 UML 的运用，我们现在的目的还是以能看懂图为目标 这个图如果写成代码就是 12345678910111213package com.qq.model;public class User { private String id; private String name; public void printName(){ }} 细心的你应该发现这个图的特点了： 如果是红色正方形图标（不管图标是不是实心），那么说明当前的访问控制修饰符是 private 如果是绿色圆形图标（不管图标是不是实心），那么说明当前的访问控制修饰符是 public 如果是黄菱形图标（不管图标是不是实心），那么说明当前的访问控制修饰符是 protected 强调一点，颜色不是最重要的，图形才是重要的，也就是正方形对应的是 private、圆形对象的是 public，因为不同的 UML 软件颜色有可能不同，我们也不需要纠结这个问题 补充一点：由于 protected 一般是和父子类在一起才生效的，所以我们在这里暂时就先不去管 protected 了。学习总是这样一点点的累加、循序渐进会更适合理解知识，每次我们扎实的掌握一点点就可以越来越强大 封装当我们了解了访问控制修饰符后，我们可以开始学习面向对象最基础的能力：封装 封装简单的来说就是把对象的属性隐藏起来，只能通过公开的方法来得到或者设置属性值。不过呢，目前业界已经形成了统一的方法规范，那就是 getter、setter 规范。举个例子 12345678910111213141516171819public class User{ //定义了一个关于名称的实例变量 private String name; /** * 获取 name 的值 */ public String getName(){ return this.name; } /** * 设置 name 的值 */ public void setName(String name){ this.name = name; }} 这里的 getName、setName 就是我们上面说的 getter、setter 方法，这个方法名的格式就是: get+属性名称（属性名的首字母要大写），用于获取属性 set+属性名称（属性名的首字母要大写），用于设置属性 这段代码还有个新的知识点，我们需要认识一下，那就是变量作用域 变量作用域Java 类进行实例化后，每一个实例都是唯一的，同样类的成员变量（实例变量）也是唯一的。这个变量的内存空间会随着类实例的创建而被创建，随着类实例的销毁而销毁（以后我们接触 JVM 的时候还会完整学习关于对象内存等知识） 那类的实例变量如何被访问呢？大家可以看看上面的代码，你会发现我们多了一个 this. 请注意，这里的 this 就是类被实例化的对象，通过 this 我们就可以很轻松的调用实例内的成员和方法。 我们也看见这个 setName 方法的参数变量名和成员变量名称是一样的，这点可能让你产生困惑了，没有关系，请记住由于 this.name 和参数 name 在不同的作用域所以可以用相同的名称。 除了实例内的作用域外，还有一个作用域是方法内，方法内的对象名称是不能重复的，并且方法内的变量是不能用修饰符的。所以下面的代码是错误的 1234567891011public void say(String name){ // 这个 private 是错误的 private String msg = &quot;hello&quot;; // 这个 name 变量名是错误的，因为重复了 String name = &quot;a&quot;; int age = 18; // 这个字符串 age 变量名是错误的，因为重复了 String age = &quot;18岁&quot;;} 当然成员变量名称也是不能重复的哦 12345public class User{ private String name; //这个数字 name 变量名称是错误的，因为重复了 private int name;} UML 封装现在我们可以继续来看一下 UML 类图中如何画出一个代表封装的类了，这个图也很容易理解一看便知 由于封装的格式很固定，所以很多时候我们都会省略掉具体的封装方法定义了，而采用如下的方式。 封装要掌握的规范其实不复杂，但是封装这件事非常复杂，因为他挑战的是我们对事物的抽象能力，这个不一下子就可以掌握好的能力，需要不断的练习和运用才可以。 常亮实例变量可以很好的支持面向对象的封装，但是有些时间我们还是需要在多个对象里共享一些数据，这个时候就需要引入常量了，常量也可以叫做静态变量。 常量和实例变量的区别在于不需要通过实例化才能得到变量，而可以直接获取或者操作变量。它的语法也非常简单，借助 static 关键字就可以。 我们来举个例子看看常量可以用在哪里，现在我们想存储和调用学校的记录。 12345678/** * 学校服务 */ public class SchoolService{ // 学校数据的常量 public static ArrayList&lt;School&gt; schools = new ArrayList&lt;&gt;(); } 当我们定义了静态变量后，我们就可以直接操作这个 schools 变量了 12345678910111213public class SchoolServiceTest{ public static void main(String[] args){ School school = new School(); school.setId(&quot;1&quot;); school.setName(&quot;北京大学&quot;); // 存储数据 SchoolService.schools.add(school); }} 我们强调过常量的特点是不需要实例化，在 Java 当中实际上是创建了一个全局唯一的内存空间并且分配给了这个变量。所以常量的值只会随 Java 的销毁才会被销毁，这样也就方便我们存储一些数据到内存中，否则会随着对象的销毁被销毁掉的。 一般我们会在两种场景上使用常量 常用的字符串值 需要在内存做缓存的值 注意：为了和变量区分开，所以一般情况下，常量的变量名采用全大写字母来定义，单词之间用 _ 分割。所以上面的学校常量应该写成 SCHOOLS 现在我们举几个例子 常用字符串的常量123456789/** * 用户Session key */public static final String USER_KEY = &quot;m_key&quot;;/** * 手机验证码 key */public static final String SMS_KEY = &quot;m_sms_key&quot;; 在这里我们多了一个关键字 final final 代表着这个变量不可以被再次修改用来保证代码安全。在字符串常量场景中经常组合使用。 从上面的常量大家应该会发现另外一个优点，那就是变量值的修改并不会影响代码调用端的修改。比如说这个 USER_KEY的值是 m_key，我们看一段代码 12345678910111213141516171819202122232425public class UserService{ public boolean hasKey(String key){ // 不使用常量的时候 if(key.equals(&quot;m_key&quot;)){ return true; } return false; }}public class UserService{ /** * 用户Session key */ public static final String USER_KEY = &quot;m_key&quot;; public boolean hasKey(String key){ // 使用常量的时候 if(key.equals(USER_KEY)){ return true; } return false; }} 对比一下这两个代码，大家想一想，如果代码继续写下去我们可能会多次运用这个 m_key，但是某一天这个m_key变成其他值的时候，是不是每个运用的地方都要单独的去修改？这个时候如果是常量就很简单了，我们只要修改 USER_KEY 的值就完事了，多方便。 内存缓存有些时候为了更高的性能，我们会缓存一些数据到内存里，举个例子我们缓存学校的数据 补充介绍一下，static 关键字除了声明静态变量外，还可以声明一个静态代码块（可以在其中执行代码并且调用 static 变量） 12345678910111213141516171819202122232425262728293031package com.youkeda.service;import com.youkeda.model.School;/** * 学校服务 */ public class SchoolService{ // 学校数据的常量 public static ArrayList&lt;School&gt; SCHOOLS = new ArrayList&lt;&gt;(); // 声明一个静态代码块，用于初始化学校数据 static{ School school = new School(); school.setId(&quot;1&quot;); school.setName(&quot;北京大学&quot;); SCHOOLS.add(school); school = new School(); school.setId(&quot;2&quot;); school.setName(&quot;清华大学&quot;); SCHOOLS.add(school); } public static void main(String[] args){ // 测试打印一下内存的数据 for(int i=0;i&lt;SCHOOLS.size();i++){ School school = SCHOOLS.get(i); System.out.println(school.getName()); } }} 代码演示 这里还有一个关系到 Java 运行的机制，static 的执行顺序是按照代码行数的顺序来执行的，所以要先声明 static 变量后再创建 static 除了 static 变量、static 代码块，我们在前面还学习过 static 方法，基本上static的用法就是这些啦。大家可以自己琢磨琢磨一下哦，记不住也没有关系我们通过练习的方式来强化。 最后我们在看一下 UML 图中常量是如何声明的 继承看一个生活中的案例：猫咪、狗狗、猴都是动物，如果我们想抽象封装猫、狗、猴这三个对象如何去做呢？ 大多数情况下，动物都可以拥有名称、年龄这两个属性，所以我们会发现这三个对象的属性相同，当然这三个动物还有很多其他的属性，我们这里只是举例。 当我们遇到这样具备相同属性以及从属某一类别、领域的对象的时候就可以考虑使用一个新的知识：继承来解决了，这也是面向对象的一项重要的能力。 继承很好理解，这个名称就是解释了。比如上面的例子，猫、狗、猴都属于动物，所以我们可以定义一个动物对象，猫、狗、猴继承这个对象即可。 在 Java 中继承的语法就是在创建类的时候多一个 extends 关键字 如上图，继承语法其实非常简单。当使用继承以后，Dog 称为 Animal 的子类，Animal 称为父类 现在我们看一下完整的代码是如何编写的 Animal.java123456789101112131415161718192021222324package com.youkeda.model;public class Animal { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} Dog.java12345package com.youkeda.model;public class Dog extends Animal{} Cat.java12345package com.youkeda.model;public class Cat extends Animal{} Monkey.java12345package com.youkeda.model;public class Monkey extends Animal{} UML 继承继承关系同样可以通过 UML 来绘制出来 OK,如上图这个箭头的图形就代表着继承的关系，注意箭头指向的类是父类哦 补充说明一下，在继承关系中，private 级别的变量或者方法子类是获取不到的，子类如果想获取父类的变量和方法可以设置父类的变量和方法为 protected 或者 public 访问控制符 我们知道每个动物吃的东西都不太一样，如果把这个行为转变为 Java 对象就需要每个 Java 对象各自去实现“吃”这个方法了，在父子类当中，子类如果想要重写父类定义的方法这个行为就叫方法覆盖 比如说，我们在 Dog 对象里覆盖 eat 方法，并打印出：狗狗喜欢肉骨头 123456789package com.youkeda.model;public class Dog extends Animal{ public void eat(){ System.out.println(&quot;狗狗喜欢吃肉骨头&quot;); }} 方法覆盖非常简单，在一些复杂的场景上运用的会比较多，这个我们在以后的项目中会再接触到 现在让我们看看如何利用父子类是如何实例化的，有点不同哦 实例化 Dog 对象123456789public class Test { public static void main(String[] args){ // 实例化 dog 对象 Dog d = new Dog(); d.setName(&quot;小灰&quot;); d.setAge(3); System.out.println(d.getName()+&quot;---&quot;+d.getAge()); }} 实例化 Animal 对象由于动物是一个抽象的对象，并没有具体指某个动物，所以一般运用动物对象是要结合它的子类的 123456789public class Test { public static void main(String[] args){ // 实例化 dog 对象并赋值给 Animal 对象 Animal d = new Dog(); d.setName(&quot;小灰&quot;); d.setAge(3); System.out.println(d.getName()+&quot;---&quot;+d.getAge()); }} 大家应该发现有个不同的用法啦 1Animal d = new Dog(); 父类对象可以直接是子类的实例。如果我们调用 d.eat() 方法，结果会是啥呢？ 代码演示 我们发现代码运行成功了，并且输出了 小灰---3以及狗狗喜欢吃肉骨头。这说明虽然我们实例化的是 Dog 子类，但是我们调用父类一样可以执行,同样我们虽然调用了父类的 eat 方法,但是由于方法覆盖的原因直接执行子类的 eat 方法了，这就是方法覆盖的用户，可以支持子类做自定义逻辑 有个特性需要大家记住的，子类的对象是可以转化为父类对象，但是父类不能转化为子类。也就是说 Dog dog = new Animal()是错误的 当我们掌握了继承这个知识后，很自然的就遇到了一个新的问题，那就是子类如果就是想调用父类的方法怎么操作呢？ 这个同样涉及到了类作用域的概念，之前我们学习过 this 这个关键字可以操作实例内的变量或者方法。那么操作父类同样也有一个关键字：super，注意super只发生在子类中 12345678910111213141516171819202122232425262728293031323334353637package com.youkeda.model;public class Animal { private String name; private int age; public void eat(){ System.out.println(&quot;动物要饿肚子啦&quot;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}public class Dog extends Animal{ public void eat(){ // 调用父类的方法 super.eat(); System.out.println(&quot;狗狗喜欢吃肉骨头&quot;); }} 现在我们测试一下这个 super 的效果 代码演示 子类运用 super 调用父类一般会发生在父类有一些通用的逻辑可以被执行。随着我们后面项目的深入会逐渐理解这句话的概念 子类的构造函数大家应该还记得这段代码吧 12345678910111213141516171819202122232425public class CustomFile{ // 存储文件路径的变量 public String filePath; // 存储文件后缀变量，通过后缀来区分文件类型 public String ext; // 声明一个构造函数，接受文件路径 public CustomFile(String filePath){ //给类变量 filePath 赋值 //this代表的是当前类的实例 this.filePath = filePath; } /** * 获取文件名称 */ public String getName(){ // 比如文件路径是 /Users/mac/work/face.png // 把文件路径分隔成数组（分隔符是 / ） // 数组的最后一位就是文件名 String[] paths = filePath.split(&quot;/&quot;); // 数组的最后一位需要减1，因为数组是从索引0开始的。 return paths[paths.length-1]; }} 当父类只有一个有参数的构造函数的时候，子类也必须要具备这个构造函数，或者调用 super 方法来实现新的构造函数 比如 12345678public class JavaFile extends CustomFile{ // 声明一个构造函数 public JavaFile(String filePath){ super(filePath); }} 我们看一下如果父类有定义构造函数而子类不定义构造函数会发生什么 代码演示 是不是看到了错误啦？这就是前面说的，如果父类定义带参数的函数子类也必须定义构造函数 1234[kind=ERROR, line=1, message=无法将类 CustomFile中的构造器 CustomFile应用到给定类型; 需要: java.lang.String 找到: 没有参数 原因: 实际参数列表和形式参数列表长度不同] 如果需要定义新的构造函数 123456789101112131415public class JavaFile extends CustomFile{ private String packageName; // 声明一个构造函数 public JavaFile(String filePath,String packageName){ super(filePath); this.packageName = packageName; } public String getPackageName(){ return this.packageName; }} 有一点需要注意的是在构造函数里的 super 方法必须写在第一行哦 接口在处理继承的时候，其实还有一些知识我们并没有去描述，那就是关于重载、多态、抽象类。因为这三个知识真的比较抽象，另外实际运用的也不是特别多，所以可以等大家熟练掌握 Java 语言后再看一看这些知识就很容易了，新手阶段我并不建议现在就去了解。 关于抽象类在以前运用的很多，但是随着 Java 对接口的升级，抽象类的使用就变得更低了，我们推荐使用接口，这也是本节课的核心内容：接口 在我们正式学习的时候，给大家看一下这个图片，大家应该都很熟悉啦，这是最新的 USB 接口：Type C 如果自己买过 USB 线大家应该会发现有非常多的商家卖各种 USB，不管是谁卖的、谁生产的都可以用（坏的不能用哈） 嗯，当我们确定这个信息后，其实就得到了接口的定义，那就是接口定义了标准、规范，各个厂商根据标准生产出自己的货品来，只要接口一致可以无缝的工作起来。在 Java 当中也存在这样的能力，同样也叫接口 interface 在 Java 当中，接口也是一个类、也包含方法，我们定义了一个接口类以后，就可以支持多个实现类，接口的调用方不用关心是谁写的实现类，只关心接口的方法参数、方法返回值就可以无缝的完成程序的对接。 如果大家想要了解关于更多 接口 的知识，可以点击查看“为什么要使用接口” 接口的语法如上图，也不复杂，就是和普通的类有一点区别，这个需要大家记住一下，多写几次就熟练啦。看一下如何创建的 代码演示 我们再看一下错误的接口方法定义,注意看一下错误信息，这也是新手容易犯的错误 代码演示 UML 接口的定义 如上图，这个图标指的就是接口（interface）： 这个图表示定义了一个 RoleService 接口，它依赖了 Role 这个类 还有一个约定请大家记住，一般情况下我们定义接口的名称遵循 XxxService,以 Service 结尾的类名称代表的就是接口，比如我们这里的 RoleService 定义好接口以后很自然就要实现接口啦。接口的实现类也遵循特定的规则，一看就明白了。 大家可以看到不管是接口还是实现，语法都是对应的英文单词（interface、implements），所以也比较好记住 这两个规则请记住哦，特别特别注意下面的： 接口定义的方法在实现类里必须要全部实现了，而且方法签名要一模一样（同样的方法名称、方法参数、方法返回值） 由于接口定义的方法都是 public 的，所以实现类的方法控制修饰符也必须是 public 除了上面的两个规则外，接口的实现类和其他类并没有什么不同。 接口和继承不同，继承表达的是父子关系，所以子类只能继承一个父类；接口是一个约定，实现类可以拥有多个约定，所以实现类可以实现多个接口，实现多个接口用”,”分开即可 定义一个 EchoService 用于输出一些内容，我们约定一个 echo 方法 1234567package com.youkeda.service;public interface EchoService { // 输出任意的内容 void echo();} 现在我们看一下一个类实现多个接口是如何实现的 123456789101112131415161718192021package com.youkeda.service.impl;import com.youkeda.service.RoleService;import com.youkeda.service.EchoService;public class RoleServiceImpl implements RoleService,EchoService{ public void addRole(Role role){ } public ArrayList&lt;Role&gt; getRoles(){ return null; } public void echo(){ }} 如何实例化接口呢？接口是不能单独实例化的，因为接口只是定义，没有具体的实现是不允许实例化的。 所以 EchoService echo = new EchoService(); 这个语法是错误的 正确的实例化是结合实现类的： 1234567891011121314151617package com.youkeda.test;import com.youkeda.service.RoleService;import com.youkeda.service.impl.RoleServiceImpl;/** * RoleServiceTest */public class RoleServiceTest { public static void main(String[] args) { RoleService roleService = new RoleServiceImpl(); }} 由于 RoleServiceImpl 类同时实现了 EchoService，所以实例也可以被转化为 EchoService。 12345678910111213141516171819package com.youkeda.test;import com.youkeda.service.RoleService;import com.youkeda.service.impl.RoleServiceImpl;/** * RoleServiceTest */public class RoleServiceTest { public static void main(String[] args) { RoleService roleService = new RoleServiceImpl(); // 类型转化：把 roleService 实例转化为 EchoService 接口类型 EchoService echoService = (EchoService)roleService; }} 这个行为稍微复杂点，大家可以想想一下我们在淘宝上买 USB 线的时候，也有那种一拖几的线（即支持苹果手机又支持 Androi 手机的线），道理是一样的，同一根线支持两种规范。线可以等同于实现类；充电头等同于接口 UML 接口实现图 如上图，代表着 RoleServiceImpl 实现了 RoleService 接口 补充说明一点：一般实现类的包名在 service 包下并且命名为 impl，同样实现类的命名规则是 XxxServiceImpl,也就是后缀是 ServiceImpl,如我们这个 com.youkeda.service.impl.RoleServiceImpl实现类","link":"/2020/04/03/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/"},{"title":"java面向对象4","text":"","link":"/2020/04/03/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14/"},{"title":"解决网页文字无法选中复制","text":"解决网页文字无法选中复制 我们在查看一些网页时会遇到不能复制的问题，或者鼠标无法选中文字，导致不能复制。 如这个下面网页 解决：按f12，点击console控制台，输入以下代码后回车即可 1234var eles = document.getElementsByTagName('*');for (var i = 0; i &lt; eles.length; i++) { eles[i].style.userSelect = 'text';}","link":"/2020/04/03/%E8%A7%A3%E5%86%B3%E7%BD%91%E9%A1%B5%E6%96%87%E5%AD%97%E6%97%A0%E6%B3%95%E9%80%89%E4%B8%AD%E5%A4%8D%E5%88%B6/"},{"title":"docker命令","text":"1&gt;.Docker镜像指令镜像检索Docker的镜像都放置在Docker官网的Docker Hub上，地址是https://registry.hub.docker.com。可在该网站搜索镜像,也可以用命令“docker search 镜像名”（如：docker search redis）检索。 镜像下载docker pull 镜像名 查看本地镜像列表docker images 删除镜像docker rmi image-id 删除所有镜像docker rmi $(docker images -q) 2&gt;.Docker容器指令运行镜像为容器docker run –name container-name -d image-name其中–name市委容器取个名称，-d表示detached，意味着执行完这句命令后控制台将不会被阻碍，可继续输入命令操作。如：docker run –name test-redis -d redis 查看运行中的容器列表docker ps通过下列命令可查看运行和停止状态的容器：docker ps -a 停止容器通过容器名称或容器ID停止容器docker stop container-name/container-id如：docker stop test-redis 启动容器通过容器名称或容器ID启动容器docker start container-name/container-id如：docker start test-redis 设置容器开机启动使用在Docker run的时候使用–restart参数来设置。no - container：不重启on-failure - container:退出状态非0时重启always:始终重启如：docker run –restart=always –name first-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 端口映射Docker容器中运行的软件所使用的端口，需要映射到当前主机的端口上才能访问。Docker的端口映射通过一个-p参数来实现。例如，我们将Redis容器的6379端口映射到本机的6378端口：docker run -d -p 6378:6379 –name port-redis redis 删除容器docker rm container-id 删除所有容器docker rm $(docker ps -a -q) 查看当前容器日志docker logs container-name/container-id如：docker logs port-redis 登陆容器运行中的容器其实是一个功能完备的Linux操作系统，所以我们可以像常规的系统一样登录并访问容器。我们可以使用如下命令，登录访问当前容器，登陆后我们可以在容器中进行常规的Linux系统操作命令，还可以使用exit命令退出登录：docker exec -it container-id/container-name bash","link":"/2020/04/09/docker%E5%91%BD%E4%BB%A4/"},{"title":"linux命令大全","text":"1. 启动,关机,登入,登出相关命令登录：login登出：logout登出：exit停止系统：shutdown停止系统：halt重启动：reboot切断电源：poweroff把内存里的内容写入磁盘：sync安装lilo启动管理程序：lilo安装lilo启动管理程序：grub 2. Shell相关命令切换Shell：chsh显示命令履历：history设置命令别名：alias取消命令别名：unalias显示命令所在位置：which查询命令种类：type显示字符串或者变量内容：echo设置/显示Shell变量：set显示环境变量：printenv设置环境变量：export设置临时环境变量：env释放环境变量：unset设置环境变量：setenv释放环境变量：unsetenv执行文件当中的命令：source查询命令手册：man查询超文本命令手册：info显示命令简介：whatisapropos通过关键字查询手册：apropos 3. 用户管理相关命令切换到其他用户：su追加用户：useradd追加用户：adduser删除用户：userdel修改用户设置：usermod修改用户私人信息：chfn追加组：groupadd删除组：groupdel修改组设置：groupmod更改密码：passwd显示用户名：whoami显示登录用户帐号：logname显示所有登录用户信息：users查询登录用户信息：who查询登录用户信息：w显示指定用户的ID信息：id显示指定用户的所属组：groups显示指定用户的个人信息：finger开关与他人收发消息：mesg给其他用户发消息：write给所有用户发消息：wall和其他用户聊天：talk 4. 系统消息相关命令显示/设置当前时间：date显示系统运行时间：uptime显示机器的核心构架（如i386）：arch显示操作系统信息：uname显示终端名：tty显示登录/登出在履历：last显示非法登录信息：lastb显示当前键盘配置：dumpkeys变更键盘配置：loadkeys查询磁盘使用信息：df查询磁盘使用信息：du显示系统启动消息：dmesg保存输入输出到文件：script 5. 文件操作相关命令显示文件列表：ls显示目录树：tree显示当前路径：pwd更改当前路径：cd追加路径到目录堆栈：pushd从目录堆栈删除路径：popd显示目录堆栈的内容：dirs创建路径：mkdir删除路径：rmdir复制文件/目录：cp删除文件/目录：rm移动文件/目录，修改文件名：mv更改文件/目录的所有者：chown修改文件/目录的所有组：chgrp修改文件/目录的权限：chmod更改文件时间：touch建立文件/目录链接：ln查找文件：find显示文件存在的路径名：whereis查询文件种类：file查询文件大小：size 6. 文件编辑相关命令显示文件内容：cat输出到文件和屏幕：tee分屏显示文件内容：more分屏显示文件内容：less显示文件头部内容：head显示文件尾部内容：tail折叠显示长行：fold排列文件的行：sort比较文件内容：cmp显示文件差异：diff更改日语文件编码：nkf变更文件之后复制：dd统计文本单词数，文件大小等：wc分割文件：split以行连接文件：paste以字段连接文件：join查询文字：grep过滤重复部分显示文件内容：uniq替换文字：tr替换文字：sed 7. 压缩/解压缩相关命令压缩/解压缩文件：ar压缩/解压缩文件：tar压缩/解压缩文件：compress解压缩：uncompress压缩/解压缩文件：gzip解压缩：gunzip显示压缩文件的内容：zcat压缩/解压缩文件：lha把二进制文件编码为文本文件：uuencode把经过编码的文本文件还原为二进制文件：uudecode MS-DOS工具集[mtools]命令 显示文件列表：mdir 改变当前目录：mcd 新建目录：mmd 删除目录：mrd 删除目录树：mdeltree 复制文件：mcopy 删除文件：mdel 移动文件：mmove 更改文件或目录名：mren 修改文件属性：mattrib 显示文件内容：mtype 查询文件或目录大小：mdu 显示磁盘信息：minfo 以MS-DOS方式格式化磁盘：mformat 设置磁盘标签：mlabel 9. 控制外部设备相关命令mount上设备：mount解除已经mount上的设备：umount弹出（CD/DVD等）：eject格式化软盘：fdformat配置/显示硬盘分区：fdisk格式化磁盘分区：mkfs检查/修复磁盘错误：fsck打印到打印机：lpr中断打印任务：lprm显示打印任务的状态：lpq管理/控制打印任务：lpc显示/设定NIC配置：ifconfig 10. 进程及任务管理相关命令显示正在运行的进程：ps显示后台运行任务：jobs把任务切换到前台：fg把任务切换到后台：bg中止进程或任务：kill中止进程或任务：killall等待进程或任务的结束：wait设置定时执行任务：at显示尚未执行的任务：atq删除定时执行任务：atrm在系统负荷减轻的时候执行任务：batch改变优先度并执行任务：nice在后台执行任务，Logout之后也不退出：nohup休眠一定的时间：sleep 11. 网络管理相关命令显示当前网络连接状况：netstat显示/设置路由：route显示网络主机情况：host显示/设置当前主机的名字：hostname确认和远程机器的连接情况：ping显示路由信息：traceroute查询网上机器的登陆用户：rwho查询网上机器的系统运行时间：ruptime登陆到远程机器：rlogin用telnet登陆到远程机器：telnet给远程机器发送命令：rsh在远程机器之间复制文件：rcp收取邮件：mail发送邮件：sendmail确认邮件队列：mailq用ftp传输文件：ftp 12. 其他命令显示日历：cal清屏：clear编译C语言代码：gcc汇编：as计算：bcRedhat的包管理：rpmDebian的包管理：dpkgSlackware的包安装（删除命令则是removepkg）：installpkg配置 X 服务器：XF86Setup,turboxfg,Xconfigurator启动 X-Window 系统：startx","link":"/2020/04/09/linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"title":"在linux上部署springboot项目","text":"","link":"/2020/04/09/%E5%9C%A8linux%E4%B8%8A%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"title":"springboot5","text":"在springboot中，普通类注入dao层报错:Autowired members must be defined in the valid spring bean (@Component/@Service,etc.) less… (Ctrl+F1) Checks autowiring problems in a bean class. 在该类中加入注解@Component可以解决 但是实际使用该类时还是报查询数据库空指针异常，仔细检查代码都没问题，数据库中也有相应数据，最后发现是调用该类时不是注入的而是new了实例。 我一直是以为Mapper的注入出了问题，，结果恰恰不是，问题出在了该类上 ，因为在LotteryUtil里面是通过注入的方式获得Mapper的实例化对象的，所以LotteryUtil对象的获得也应该采用注入的方式（前后一致），这样才能得到这个类扫面后创建的Mapper的实例化对象（可参考源码）。如果是new 出来的LotteryUtli对象的话，它的中的@Autowired注解是不起作用的，因为自己new出来的对象不是spring容器中的，无法使用注入，因此Mapper对象当然为NULL啦。 还有最让人头疼的就是，开发工具昨天抽筋了，明明之前已经写对了，但是编译不及时，依然报错…….重启之后再打开，莫名的又编译成功了，，所以，睡一觉还是有这么点好处的(玩笑话），clean之后再执行编译，其实也是可以的。","link":"/2020/04/07/springboot5/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"linux","slug":"linux","link":"/tags/linux/"}],"categories":[]}